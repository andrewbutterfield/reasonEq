{-
  LBNF Syntax for reasonEq Terms and Theories,
  with an emphasis on Unifying Theories of Programming

  The plan is to replace the current editable syntax in UTP
  (Theory.src) with a nicer syntax.

  Currently a theory file has the format:

  Theory <thryname>
  Needs
    <importnm1> <importnm2> ... <importnmN>
  END
  Known A {O NS} : ( ( P LE ) -> ( B -> ( ( P LE ) -> B ) ) ) .
  Known 'ls {O} : ( P LE ) .
  Known ls' {O} : ( P LE ) .
  Known 'O$ = < 's,'ls >
  Law <lawname> BEGIN
    axiom ,
    <predicate> ,
  VREL (DISJ E FROM 'O$ O$') ... (DYNCOV a BY 's s')
  END
  Conjecture <conjname> BEGIN
    <predicate>
  , VREL <atomicSc1> ... <atomicScN>
  END

  We need (bottom-up)
    Types  -- done
    Expressions -- covers arithmetic and cons-lists
    Predicates 
      -- covers propositions, equality, ordering, predicate transformers
    Terms = Expressions+Predicates -- done
    Variable Data -- covers what's actually used
      -- this is a monster - see below
      -- now we only implement what is actually used.
    Substitutions -- done
    Side-Conditions -- done
    Quantifiers -- TBD
    Iterators, etc.... TBD
    Top-level theory structuring: -- done
      Named-Assertions; Known-Declarations; Theory-Imports; Named-Theory

-}

-- we want identifiers to start with letters and underscores
token DynVar  ( (letter|'_') (letter|digit|'_')* ) ;

{- Theories
   SourceHandling syntex  ( .src )

   Theory EQV
   Known eqv {O CS} : ( B -> ( B -> B ) ) .
   Law true BEGIN axiom, true END
   Law eqv_refl BEGIN axiom, eqv ( P , P ) END
   Law non_subst 
     BEGIN axiom
       , eqv ( SUB [(x$,e$)] P , P )
       , VREL (DISJ P FROM x$)
     END
   Conjecture eqv_id BEGIN eqv ( eqv ( true , Q ) , Q ) END

   So, a theory has:
     a name;
     a list of zero or more dependent theories;
     a list of one of more theory items.
   Theory items are:
     Default variable-name interpretations;
     Known variable declarations;
     Conjectures;
     Laws.

 The Defaults are a new concept. 
 These were typically hard coded in the Haskell files.
 Now we declare them in the .utp file and their effect is local to that file.
 We have an implicit global set of defaults that get overidden by
 explicit defaults and known variable declarations.
-}

Thr. Thry ::= "Theory" DynVar "." [DynVar] "." [Item] ;

separator DynVar "" ;

{- Default Variable interpretations

  These are items that declare that specific variable names, 
  if not declared elsewhere, have certain charactersitics.
  For now this includes Variable Class (Obs,Expr,Pred),
  and certain temporal cases: Static, Textual(?).

  Single-letter variables get classifed by default as follows:
 
  Upper-Case:  Predicate, Static
  Lower-Case:
    a..h  Expr, Static
    i..n  Obs, Static
    p..s  Pred, Before  
    u..z  Obs, Dynamic
    not sure about o or t 

    So far, list variables are Dynamic Obs.

-}

DefObs.    Item ::= "ObsVars"    [DynVar] "." ; -- dynamic by default
DefExpr.   Item ::= "ExprVars"   [DynVar] "." ; -- static by default
DefPred.   Item ::= "PredVars"   [DynVar] "." ; -- static by default
DefStatic. Item ::= "StaticVars" [DynVar] "." ; 

{- Variable Data 

      newtype VarTable
        = VD ( String
            , Map Variable   VarMatchRole
            , Map Variable   LstVarMatchRole
            , Map IdAndClass DynamicLstVarRole
            )

      data VarMatchRole -- Variable Matching Role
        =  KT Term     -- Known Term   -- used in Proto.thr
        |  KV Type (Maybe Subable) -- Known Variable -- widely used
        |  KG          -- Generic Variable -- used in Proto.thr
        |  KI Variable -- Instance Variable ! variable must be known as generic
                              -- used in Proto.thr
        |  UV          -- Unknown Variable -- never explicitly represented

      data LstVarMatchRole -- ListVar Matching Roles
      = KL VarList        -- Known Variable-List (all known?) -- Proto.thr
            [Variable]     -- full expansion
            Int            -- length of full expansion
      | KS VarSet         -- Known Variable-Set (all known?) -- Proto.thr
            (Set Variable) -- full expansion
            Int            -- size of full expansion
      | AL                -- Abstract Known Variable-List  -- Proto.thr
      | AS                -- Abstract Known Variable-Set -- Proto.thr
      | UL                -- Unknown List-Variable -- never explicitly represented

      data DynamicLstVarRole -- Dynamic ListVar Matching Roles
      = DL [Identifier]      -- Known-list, Variable identifiers -- UTCP,Proto
            [Identifier]      -- Known-list, List-Variable identifiers
            [Identifier]      -- full expansion
            Int               -- length of full expansion
      | DS (Set Identifier)  -- Known-set, Variable identifiers -- Proto.thr
            (Set Identifier)  -- Known-set, List-Variable identifiers
            (Set Identifier)  -- full expansion
            Int               -- size of full expansion
      | DAL                  -- Abstract Known List  -- Proto.thr
      | DAS                  -- Abstract Known Set   -- UWhile,Proto
      | UD         -- Unknown Dynamic List-Variable

  For now we only implement stuff actually used !
  This is  KV DL DAS 
-}

DeclVar.   Item ::= "DclVar" VClass DynVar "." VarRole "."    ;  -- KV
DeclDLVar. Item ::= "DclDLVar" VClass DynVar "." [DynVar] "." ;  -- DL
DeclASet.  Item ::= "DclASet" VClass DynVar "."               ;  -- DAS
Conj.      Item ::= "Conjecture" DynVar "." Trm "." SCond  ;
Law.       Item ::= "Law" LawType DynVar "." Trm "." SCond  ;

KV. VarRole ::= "var" SBBL Typ ;

VarObs. VClass ::= "Obs" ;
VarExp. VClass ::= "Exp" ;
VarPred. VClass ::= "Prd" ;

Na. SBBL ::= "NA" ;
SB. SBBL ::= "SB" ;
NS. SBBL ::= "NS" ;

LAxiom.  LawType ::= "axiom" ;
LProof.  LawType ::= "proven" ;
LAssume. LawType ::= "assumed" ;

separator Item "" ;

{- Terms (Expressions,Predicates)
   Haskell and Propositional binary operators (tightest first):
      | Left-Assoc           |         Non-Assoc            | Right-Assoc
      | !!                   |                              | . 
      |                      |                              | ^ ^^ **
   7  | * / div mod rem quot |                              | 
   6  | + -                  |                              |
   5  |                      |                              | : ++
   4  |                      | == /= < <= > >= elem notElem |
                  programs as predicates will probably live here      
   3  |                      |                              | && /\
   2  |                      |                              | || \/
   1  |                      |                              | ==>
   0  |                      |                              | ===
      | >> >>=               |                              |
      |                      |                              | $ $! seq   
-}
PEqv.   Trm  ::= Trm "===" Trm1 ;
PImpl.  Trm1 ::= Trm2 "==>" Trm1 ;
POr.    Trm2 ::= Trm2 "\\/" Trm3 ;
PAnd.   Trm3 ::= Trm3 "/\\" Trm4 ;
PNot.   Trm3 ::= "~" Trm4 ;
-- program predicates ?
Eql.    Trm4 ::= Trm5 "==" Trm5 ;
NE.     Trm4 ::= Trm5 "!=" Trm5 ;
Lt.     Trm4 ::= Trm5 "<" Trm5 ;
LE.     Trm4 ::= Trm5 "<=" Trm5 ;
Gt.     Trm4 ::= Trm5 ">" Trm5 ;
GE.     Trm4 ::= Trm5 ">=" Trm5 ;
LCat.   Trm5 ::= Trm6  "++" Trm5 ;
LCons.  Trm5 ::= Trm6  ":"  Trm5 ;
EAdd.   Trm6 ::= Trm6  "+"  Trm7 ;
EMinus. Trm6 ::= Trm6  "-"  Trm7 ;
EMul.   Trm7 ::= Trm7  "*"  Trm8 ;
EDiv.   Trm7 ::= Trm7 "div" Trm8 ;
EMod.   Trm7 ::= Trm7 "mod" Trm8 ;
ENeg.   Trm7 ::= "neg" Trm8 ;
EInt.   Trm8 ::= Integer ;
TmVar.  Trm8 ::= DynVar ;
TTrue.  Trm8 ::= "True" ;
TFalse. Trm8 ::= "False" ;
ENil.   Trm8 ::= "nil" ;
TCons.  Trm8 ::= DynVar "(" [Trm] ")" ;
TSubV.  Trm8  ::= "SubV" Trm "[." [Trm] "/" [DynVar] ".]" ;
TSubLV. Trm8 ::= "SubL" Trm  "[." [DynVar] "/" [DynVar] ".]" ;
TSubst. Trm8 ::= "Sub" Trm 
                     "[." [Trm] "/" [DynVar] 
                          "|" 
                          [DynVar] "/" [DynVar]
                     ".]" ;
coercions Trm 8 ;
separator Trm "," ;


{- Types
  reasonEq Typ(s)
    ArbType
    TypeVar i  
    TypeCons i ts 
    AlgType i fs 
    FunType td tr 
    GivenType i  - here we treat these as TypeVar
    BottomType
    ts = [t1,..,tN]
    fs = [(i_1,ts_1),..,(i_M,ts_M)]
    t1 -> t2 -> t3   is  t1 -> (t2 -> t3)
-}

TFun.  Typ ::= Typ1 "->" Typ ;
TRec.  Typ1 ::= DynVar "(:" [Typ2] ":)" ;
TProd. Typ2 ::= DynVar [Typ3] ;
TArb.  Typ3 ::= "ttop" ;
TVbl.  Typ3 ::= DynVar ; 
TBot.  Typ3 ::= "tbot" ;
coercions Typ 3 ;
separator Typ2 "|" ;
separator Typ3 "" ;

{- Side-Conditions
    type SideCond = ( [VarSideConds]  -- all must be true
                    , VarSet )       -- must be fresh
    data  VarSideConds -- (V,D,C,Cd)
      = VSC  GenVar      --  v,T,l$
            (NA VarSet)  --  D, if applicable
            (NA VarSet)  --  C, if applicable
            (NA VarSet)  --  Cd, if applicable
    data NA t = NA | The t -- we can ignore this
-}

SVar. GVar ::= "std" DynVar ;
LVar. GVar ::= "lst" DynVar ;
separator GVar "," ;

VSet. VrSet ::= [GVar] ;

VSCDisj.   VSCond ::= GVar "disj"   VrSet ;
VSCCovBy.  VSCond ::= GVar "covby"  VrSet ;
VSCDynCov. VSCond ::= GVar "dcovby" VrSet ;
separator VSCond ";" ;

SCFull.  SCond ::= "SC" [VSCond] "." VrSet "." ;
SCVSCs.  SCond ::= "VSC" [VSCond] "." ;
SCFresh. SCond ::= "fresh" VrSet "." ;
SCnone.  SCond ::= "none" ;

entrypoints Thry, Trm, Typ, SCond ;