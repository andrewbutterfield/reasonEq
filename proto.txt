Theory Sets
Needs
  Impl EQV Equal Forall Arith
}


Known card : (P t) -> Z .
Known emptyset : P t .
Known intsct : (P t) -> (P t) -> P t .
Known mbr : t -> (P t) -> B .
Known sdiff : (P t) -> (P t) -> P t .
Known subseteq : (P t) -> (P t) -> B .
Known union : (P t) -> (P t) -> P t .




Law mbr_emptyset
{ axiom
,
eq CS (mbr CS (x,emptyset),false)
}

Law mbr_singleton
{ axiom
,
eq CS (mbr CS (x,set CS (y)),eq CS (x,y))
}

Law set_eq_def
{ axiom
,
eqv CS (eq CS (S1,S2),B-stuff?)
}

Law subseteq_def
{ axiom
,
eqv CS (subseteq CS (S1,S2),B-stuff?)
}

Law mbr_union_def
{ axiom
,
eqv CS (mbr CS (x,union CS (S1,S2)),or CS (mbr CS (x,S1),mbr CS (x,S2)))
}

Law mbr_intsct_def
{ axiom
,
eqv CS (mbr CS (x,intsct CS (S1,S2)),and CS (mbr CS (x,S1),mbr CS (x,S2)))
}

Law mbr_sdiff_def
{ axiom
,
eqv CS (mbr CS (x,sdiff CS (S1,S2)),and CS (mbr CS (x,S1),not CS (mbr CS (x,S2))))
}

Law card_emptyset_def
{ axiom
,
eq CS (card CS (emptyset),0)
}

Law card_single_def
{ axiom
,
eq CS (card CS (set CS (x)),1)
}

Law card_union_def
{ axiom
,
eq CS (card CS (union CS (S1,S2)),sub CS (add CS (card CS (S1),card CS (S2)),card CS (intsct CS (S1,S2))))
}

Conjecture mbr_set_self
{
eq CS (mbr CS (x,set CS (x)),true)
}

Conjecture union_r_unit
{
eq CS (union CS (S,emptyset),S)
}

Conjecture union_symm
{
eq CS (union CS (S1,S2),union CS (S2,S1))
}

Conjecture union_assoc
{
eq CS (union CS (S1,union CS (S2,S3)),union CS (union CS (S1,S2),S3))
}

Conjecture intsct_zero
{
eq CS (intsct CS (S,emptyset),emptyset)
}

Conjecture intsct_symm
{
eq CS (intsct CS (S1,S2),intsct CS (S2,S1))
}

Conjecture intsct_assoc
{
eq CS (intsct CS (S1,intsct CS (S2,S3)),intsct CS (intsct CS (S1,S2),S3))
}

Conjecture sdiff_r_unit
{
eq CS (sdiff CS (S,emptyset),S)
}

Conjecture sdiff_l_assoc
{
eq CS (sdiff CS (sdiff CS (S1,S2),S3),sdiff CS (S1,union CS (S2,S3)))
}

Conjecture sdiff_r_assoc
{
eq CS (sdiff CS (S1,sdiff CS (S2,S3)),union CS (sdiff CS (S1,S2),intsct CS (S1,S3)))
}

Conjecture union_intsct_distr
{
eq CS (intsct CS (union CS (S1,S2),S3),union CS (intsct CS (S1,S3),intsct CS (S2,S3)))
}

Conjecture intsct_union_distr
{
eq CS (union CS (intsct CS (S1,S2),S3),intsct CS (union CS (S1,S3),union CS (S2,S3)))
}

Conjecture union_sdiff_distr
{
eq CS (sdiff CS (union CS (S1,S2),S3),union CS (sdiff CS (S1,S3),sdiff CS (S2,S3)))
}

Conjecture intsct_sdiff_distr
{
eq CS (sdiff CS (intsct CS (S1,S2),S3),intsct CS (sdiff CS (S1,S3),sdiff CS (S2,S3)))
}

Conjecture sdiff_union_r_distr
{
eq CS (sdiff CS (S1,union CS (S2,S3)),intsct CS (sdiff CS (S1,S2),sdiff CS (S1,S3)))
}

Conjecture sdiff_intsct_r_distr
{
eq CS (sdiff CS (S1,intsct CS (S2,S3)),union CS (sdiff CS (S1,S2),sdiff CS (S1,S3)))
}

Conjecture sdiff_union_l_distr
{
eq CS (union CS (sdiff CS (S1,S2),S3),sdiff CS (union CS (S1,S3),sdiff CS (S2,S3)))
}

Conjecture sdiff_intsct_l_distr
{
eq CS (intsct CS (sdiff CS (S1,S2),S3),sdiff CS (intsct CS (S1,S3),S2))
}
