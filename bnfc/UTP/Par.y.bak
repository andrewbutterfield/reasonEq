-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.7).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module UTP.Par
  ( happyError
  , myLexer
  , pTheory
  , pPred
  , pExp
  , pType
  ) where

import Prelude

import qualified UTP.Abs
import UTP.Lex

}

%name pTheory Theory
%name pPred Pred
%name pExp Exp
%name pType Type
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='         { PT _ (TS _ 1)      }
  '('          { PT _ (TS _ 2)      }
  '(.'         { PT _ (TS _ 3)      }
  '(:'         { PT _ (TS _ 4)      }
  ')'          { PT _ (TS _ 5)      }
  '*'          { PT _ (TS _ 6)      }
  '+'          { PT _ (TS _ 7)      }
  '++'         { PT _ (TS _ 8)      }
  ','          { PT _ (TS _ 9)      }
  '-'          { PT _ (TS _ 10)     }
  '->'         { PT _ (TS _ 11)     }
  '.'          { PT _ (TS _ 12)     }
  '.)'         { PT _ (TS _ 13)     }
  '/\\'        { PT _ (TS _ 14)     }
  ':'          { PT _ (TS _ 15)     }
  ':)'         { PT _ (TS _ 16)     }
  '<'          { PT _ (TS _ 17)     }
  '<='         { PT _ (TS _ 18)     }
  '=='         { PT _ (TS _ 19)     }
  '==='        { PT _ (TS _ 20)     }
  '==>'        { PT _ (TS _ 21)     }
  '>'          { PT _ (TS _ 22)     }
  '>='         { PT _ (TS _ 23)     }
  'Conjecture' { PT _ (TS _ 24)     }
  'DclDLVar'   { PT _ (TS _ 25)     }
  'DclVar'     { PT _ (TS _ 26)     }
  'E'          { PT _ (TS _ 27)     }
  'Law'        { PT _ (TS _ 28)     }
  'NA'         { PT _ (TS _ 29)     }
  'NS'         { PT _ (TS _ 30)     }
  'SB'         { PT _ (TS _ 31)     }
  'T'          { PT _ (TS _ 32)     }
  'Theory'     { PT _ (TS _ 33)     }
  '\\/'        { PT _ (TS _ 34)     }
  'assumed'    { PT _ (TS _ 35)     }
  'axiom'      { PT _ (TS _ 36)     }
  'div'        { PT _ (TS _ 37)     }
  'false'      { PT _ (TS _ 38)     }
  'mod'        { PT _ (TS _ 39)     }
  'neg'        { PT _ (TS _ 40)     }
  'nil'        { PT _ (TS _ 41)     }
  'proven'     { PT _ (TS _ 42)     }
  'tbot'       { PT _ (TS _ 43)     }
  'true'       { PT _ (TS _ 44)     }
  'ttop'       { PT _ (TS _ 45)     }
  'var'        { PT _ (TS _ 46)     }
  '|'          { PT _ (TS _ 47)     }
  '~'          { PT _ (TS _ 48)     }
  L_integ      { PT _ (TI $$)       }
  L_DynVar     { PT _ (T_DynVar $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

DynVar :: { UTP.Abs.DynVar }
DynVar  : L_DynVar { UTP.Abs.DynVar $1 }

Theory :: { UTP.Abs.Theory }
Theory
  : 'Theory' DynVar '.' ListDynVar '.' ListItem { UTP.Abs.Thry $2 $4 $6 }

ListDynVar :: { [UTP.Abs.DynVar] }
ListDynVar : {- empty -} { [] } | DynVar ListDynVar { (:) $1 $2 }

Item :: { UTP.Abs.Item }
Item
  : 'DclVar' DynVar '.' VarRole '.' { UTP.Abs.DeclVar $2 $4 }
  | 'DclDLVar' DynVar '.' ListDynVar '.' { UTP.Abs.DeclDLVar $2 $4 }
  | 'Conjecture' DynVar '.' Pred '.' { UTP.Abs.Conj $2 $4 }
  | 'Law' LawType DynVar '.' Pred '.' { UTP.Abs.Law $2 $3 $5 }

VarRole :: { UTP.Abs.VarRole }
VarRole : 'var' SBBL Type { UTP.Abs.VMR_KV $2 $3 }

SBBL :: { UTP.Abs.SBBL }
SBBL
  : 'NA' { UTP.Abs.SBBL_NA }
  | 'SB' { UTP.Abs.SBBL_SB }
  | 'NS' { UTP.Abs.SBBL_NS }

LawType :: { UTP.Abs.LawType }
LawType
  : 'axiom' { UTP.Abs.LAxiom }
  | 'proven' { UTP.Abs.LProof }
  | 'assumed' { UTP.Abs.LAssume }

ListItem :: { [UTP.Abs.Item] }
ListItem : {- empty -} { [] } | Item ListItem { (:) $1 $2 }

Pred :: { UTP.Abs.Pred }
Pred : Pred '===' Pred1 { UTP.Abs.PEqv $1 $3 } | Pred1 { $1 }

Pred1 :: { UTP.Abs.Pred }
Pred1 : Pred2 '==>' Pred1 { UTP.Abs.PImpl $1 $3 } | Pred2 { $1 }

Pred2 :: { UTP.Abs.Pred }
Pred2 : Pred2 '\\/' Pred3 { UTP.Abs.POr $1 $3 } | Pred3 { $1 }

Pred3 :: { UTP.Abs.Pred }
Pred3 : Pred3 '/\\' Pred4 { UTP.Abs.PAnd $1 $3 } | Pred4 { $1 }

Pred4 :: { UTP.Abs.Pred }
Pred4 : '~' Pred5 { UTP.Abs.PNot $2 } | Pred5 { $1 }

Pred5 :: { UTP.Abs.Pred }
Pred5
  : Exp '==' Exp { UTP.Abs.EQ $1 $3 }
  | Exp '!=' Exp { UTP.Abs.NE $1 $3 }
  | Exp '<' Exp { UTP.Abs.LT $1 $3 }
  | Exp '<=' Exp { UTP.Abs.LE $1 $3 }
  | Exp '>' Exp { UTP.Abs.GT $1 $3 }
  | Exp '>=' Exp { UTP.Abs.GE $1 $3 }
  | Pred6 { $1 }

Pred6 :: { UTP.Abs.Pred }
Pred6
  : DynVar { UTP.Abs.PVar $1 }
  | 'E' Exp { UTP.Abs.PExpr $2 }
  | 'T' Type { UTP.Abs.PType $2 }
  | DynVar '(.' ListPred '.)' { UTP.Abs.PredTX $1 $3 }
  | '(' Pred ')' { $2 }

ListPred :: { [UTP.Abs.Pred] }
ListPred
  : {- empty -} { [] }
  | Pred { (:[]) $1 }
  | Pred ',' ListPred { (:) $1 $3 }

Exp :: { UTP.Abs.Exp }
Exp
  : Exp1 '++' Exp { UTP.Abs.ECat $1 $3 }
  | Exp1 ':' Exp { UTP.Abs.ECons $1 $3 }
  | Exp1 { $1 }

Exp1 :: { UTP.Abs.Exp }
Exp1
  : Exp1 '+' Exp2 { UTP.Abs.EAdd $1 $3 }
  | Exp1 '-' Exp2 { UTP.Abs.ESub $1 $3 }
  | Exp2 { $1 }

Exp2 :: { UTP.Abs.Exp }
Exp2
  : Exp2 '*' Exp3 { UTP.Abs.EMul $1 $3 }
  | Exp2 'div' Exp3 { UTP.Abs.EDiv $1 $3 }
  | Exp2 'mod' Exp3 { UTP.Abs.EMod $1 $3 }
  | 'neg' Exp3 { UTP.Abs.ENeg $2 }
  | Exp3 { $1 }

Exp3 :: { UTP.Abs.Exp }
Exp3
  : Integer { UTP.Abs.EInt $1 }
  | DynVar { UTP.Abs.EVar $1 }
  | 'true' { UTP.Abs.ETrue }
  | 'false' { UTP.Abs.EFalse }
  | 'nil' { UTP.Abs.ENil }
  | DynVar '(' ListExp ')' { UTP.Abs.ENmdTuple $1 $3 }
  | '(' Exp ')' { $2 }

ListExp :: { [UTP.Abs.Exp] }
ListExp
  : {- empty -} { [] }
  | Exp { (:[]) $1 }
  | Exp ',' ListExp { (:) $1 $3 }

Type :: { UTP.Abs.Type }
Type : Type1 '->' Type { UTP.Abs.TFun $1 $3 } | Type1 { $1 }

Type1 :: { UTP.Abs.Type }
Type1
  : DynVar '(:' ListType2 ':)' { UTP.Abs.TRec $1 $3 } | Type2 { $1 }

Type2 :: { UTP.Abs.Type }
Type2 : DynVar ListType3 { UTP.Abs.TProd $1 $2 } | Type3 { $1 }

Type3 :: { UTP.Abs.Type }
Type3
  : 'ttop' { UTP.Abs.TArb }
  | DynVar { UTP.Abs.TVar $1 }
  | 'tbot' { UTP.Abs.TBot }
  | '(' Type ')' { $2 }

ListType2 :: { [UTP.Abs.Type] }
ListType2
  : {- empty -} { [] }
  | Type2 { (:[]) $1 }
  | Type2 '|' ListType2 { (:) $1 $3 }

ListType3 :: { [UTP.Abs.Type] }
ListType3 : {- empty -} { [] } | Type3 ListType3 { (:) $1 $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

