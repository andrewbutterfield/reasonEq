{-
  LBNF Syntax for reasonEq Terms and Theories,
  with an emphasis on Unifying Theories of Programming

  The plan is to replace the current editable syntax in UTP
  (Theory.src) with a nicer syntax.

  Currently a theory file has the format:

  Theory <thryname>
  Needs
    <importnm1> <importnm2> ... <importnmN>
  END
  Known A {O NS} : ( ( P LE ) -> ( B -> ( ( P LE ) -> B ) ) ) .
  Known 'ls {O} : ( P LE ) .
  Known ls' {O} : ( P LE ) .
  Known 'O$ = < 's,'ls >
  Law <lawname> BEGIN
    axiom ,
    <predicate> ,
  VREL (DISJ E FROM 'O$ O$') ... (DYNCOV a BY 's s')
  END
  Conjecture <conjname> BEGIN
    <predicate>
  , VREL <atomicSc1> ... <atomicScN>
  END

  We need (bottom-up)
    Types  -- done
    Expressions -- covers arithmetic and cons-lists
    Predicates 
      -- covers propositions, equality, ordering, predicate transformers
    Here: we have enough to represent the propositional theories

    Once quantifiers are introduced we need:
    Side-Conditions

    Top-level theory structuring:
    Named-Assertions
    Known-Declarations
    Theory-Imports
    Named-Theory

-}

-- we want to add a boolean type
token Boolean ( {"false"} | {"true"} ) ;

-- we want identifiers to start with letters and underscores
token DynVar  ( (letter|'_') (letter|digit|'_')* ) ;


{- Predicates

   Propositional precedence:  tight..loose: ~ /\ \/ ==> ===
-}
PEqv.  Pred  ::= Pred "===" Pred1   ;
PImpl. Pred1 ::= Pred2 "==>" Pred1  ;
POr.   Pred2 ::= Pred2 "\\/" Pred3  ;
PAnd.  Pred3 ::= Pred3 "/\\" Pred4  ;
PNot.  Pred4 ::= "~" Pred5          ;
EQ.    Pred5 ::= Exp "==" Exp       ; 
NE.    Pred5 ::= Exp "!=" Exp       ; 
LT.    Pred5 ::= Exp "<" Exp        ; 
LE.    Pred5 ::= Exp "<=" Exp       ; 
GT.    Pred5 ::= Exp ">" Exp        ; 
GE.    Pred5 ::= Exp ">=" Exp       ; 
PVar.  Pred6 ::= DynVar              ;
PExpr. Pred6 ::= "E" Exp            ;
PType. Pred6 ::= "T" Type ;
PredTX. Pred6 ::= DynVar "(." [Pred] ".)" ;
coercions Pred 6                    ;

separator Pred "," ;


{- Expressions  

  Haskell operators:
   Prc | Left-Assoc           |         Non-Assoc            | Right-Assoc
    9  | !!                   |                              | . 
    8  |                      |                              | ^ ^^ **
    7  | * / div mod rem quot |                              | 
    6  | + -                  |                              |
    5  |                      |                              | : ++
    4  |                      | == /= < <= > >= elem notElem | 
    3  |                      |                              | &&
    2  |                      |                              | ||
    1  | >> >>=               |                              |
    0  |                      |                              | $ $! seq
    
-}


ECat.  Exp  ::= Exp1  "++" Exp  ;
ECons. Exp  ::= Exp1  ":"  Exp  ;
EAdd.  Exp1 ::= Exp1  "+"  Exp2 ;
ESub.  Exp1 ::= Exp1  "-"  Exp2 ;
EMul.  Exp2 ::= Exp2  "*"  Exp3 ;
EDiv.  Exp2 ::= Exp2 "div" Exp3 ;
EMod.  Exp2 ::= Exp2 "mod" Exp3 ;
ENeg.  Exp2 ::= "neg" Exp3      ;
EInt.  Exp3 ::= Integer         ;
EVar.  Exp3 ::= DynVar           ;
EBool. Exp3 ::= Boolean         ;
ENil.  Exp3 ::= "nil"           ;
ENmdTuple. Exp3 ::= DynVar "(" [Exp] ")" ;
coercions Exp 3                 ;

separator Exp "," ;

{- Types

  reasonEq Type(s)

  ArbType
  TypeVar i  
  TypeCons i ts 
  AlgType i fs 
  FunType td tr 
  GivenType i  - here we treat these as TypeVar
  BottomType
  ts = [t1,..,tN]
  fs = [(i_1,ts_1),..,(i_M,ts_M)]

  t1 -> t2 -> t3   is  t1 -> (t2 -> t3)

-}

TFun.  Type ::= Type1 "->" Type ;
TRec.  Type1 ::= DynVar "(:" [Type2] ":)" ;
TProd. Type2 ::= DynVar [Type3] ;
TArb.  Type3 ::= "ttop" ;
TVar.  Type3 ::= DynVar ; 
TBot.  Type3 ::= "tbot" ;
coercions Type 3 ;

separator Type2 "|" ;
separator Type3 "" ;

entrypoints Pred, Exp, Type ;