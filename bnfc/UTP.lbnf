{-
  LBNF Syntax for reasonEq Terms and Theories,
  with an emphasis on Unifying Theories of Programming

  The plan is to replace the current editable syntax in UTP
  (Theory.src) with a nicer syntax.

  Currently a theory file has the format:

  Theory <thryname>
  Needs
    <importnm1> <importnm2> ... <importnmN>
  END
  Known A {O NS} : ( ( P LE ) -> ( B -> ( ( P LE ) -> B ) ) ) .
  Known 'ls {O} : ( P LE ) .
  Known ls' {O} : ( P LE ) .
  Known 'O$ = < 's,'ls >
  Law <lawname> BEGIN
    axiom ,
    <predicate> ,
  VREL (DISJ E FROM 'O$ O$') ... (DYNCOV a BY 's s')
  END
  Conjecture <conjname> BEGIN
    <predicate>
  , VREL <atomicSc1> ... <atomicScN>
  END

  We need (bottom-up)
    Types
    Expressions
    Predicates
    Side-Conditions
    Named-Assertions
    Known-Declarations
    Theory-Imports
    Named-Theory

-}

-- we want to add a boolean type
token Boolean ( {"false"} | {"true"} ) ;

-- we want identifiers to start with letters and underscores
token DynVar  ( (letter|'_') (letter|digit|'_')* ) ;


{- 
   We define a predicate type (expressions of type Bool)

   Propositional precedence:  tight..loose: ~ /\ \/ ==> ===
-}
PEqv.  Pred  ::= Pred "===" Pred1   ;
PImpl. Pred1 ::= Pred2 "==>" Pred1  ;
POr.   Pred2 ::= Pred2 "\\/" Pred3  ;
PAnd.  Pred3 ::= Pred3 "/\\" Pred4  ;
PNot.  Pred4 ::= "~" Pred5          ;
EQ.    Pred5 ::= Exp "==" Exp       ; 
NE.    Pred5 ::= Exp "!=" Exp       ; 
LT.    Pred5 ::= Exp "<" Exp        ; 
LE.    Pred5 ::= Exp "<=" Exp       ; 
GT.    Pred5 ::= Exp ">" Exp        ; 
GE.    Pred5 ::= Exp ">=" Exp       ; 
PVar.  Pred6 ::= DynVar              ;
PLift. Pred6 ::= "E" Exp            ;
PredTX. Pred6 ::= DynVar "(." [Pred] ".)" ;
coercions Pred 6                    ;

separator Pred "," ;


{- 
  We then define a generic expression type.

  Haskell operators:
   Prc | Left-Assoc           |         Non-Assoc            | Right-Assoc
    9  | !!                   |                              | . 
    8  |                      |                              | ^ ^^ **
    7  | * / div mod rem quot |                              | 
    6  | + -                  |                              |
    5  |                      |                              | : ++
    4  |                      | == /= < <= > >= elem notElem | 
    3  |                      |                              | &&
    2  |                      |                              | ||
    1  | >> >>=               |                              |
    0  |                      |                              | $ $! seq
    
-}


ECat.  Exp  ::= Exp1  "++" Exp  ;
ECons. Exp  ::= Exp1  ":"  Exp  ;
EAdd.  Exp1 ::= Exp1  "+"  Exp2 ;
ESub.  Exp1 ::= Exp1  "-"  Exp2 ;
EMul.  Exp2 ::= Exp2  "*"  Exp3 ;
EDiv.  Exp2 ::= Exp2 "div" Exp3 ;
EMod.  Exp2 ::= Exp2 "mod" Exp3 ;
ENeg.  Exp2 ::= "neg" Exp3      ;
EInt.  Exp3 ::= Integer         ;
EVar.  Exp3 ::= DynVar           ;
EBool. Exp3 ::= Boolean         ;
ENil.  Exp3 ::= "nil"           ;
ENmdTuple. Exp3 ::= DynVar "(" [Exp] ")" ;
coercions Exp 3                 ;

separator Exp "," ;
