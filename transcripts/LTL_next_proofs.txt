Theory 'LTL'
depends on: Equality,Exists,ForAll,Implies,AndOrInvert,And,Or,Not,Equiv
Knowns:
â—» :  ð”¹ âŸ¶  ð”¹ 
â—‡ :  ð”¹ âŸ¶  ð”¹ 
â—‹ :  ð”¹ âŸ¶  ð”¹ 
until :  ð”¹ âŸ¶  ð”¹ âŸ¶  ð”¹ 
wait :  ð”¹ âŸ¶  ð”¹ âŸ¶  ð”¹ 
Laws:
   1. âŠ¤  â€œnext_self_dualâ€      â—‹(Â¬P) â‰¡ Â¬â—‹(P)  âŠ¤
   2. âŠ¤  â€œnext_implies_distrâ€  â—‹(P âŸ¹   Q) â‰¡ â—‹(P) âŸ¹   â—‹(Q)  âŠ¤
   3. âˆŽ  â€œlinearityâ€           â—‹(P) â‰¡ Â¬â—‹(Â¬P)  âŠ¤
   4. âˆŽ  â€œnext_trueâ€           â—‹(true) â‰¡ true  âŠ¤
   5. âˆŽ  â€œnext_falseâ€          â—‹(false) â‰¡ false  âŠ¤
   6. âˆŽ  â€œnext_or_distrâ€       â—‹(P âˆ¨ Q) â‰¡ â—‹(P) âˆ¨ â—‹(Q)  âŠ¤
   7. âˆŽ  â€œnext_and_distrâ€      â—‹(P âˆ§ Q) â‰¡ â—‹(P) âˆ§ â—‹(Q)  âŠ¤
   8. âˆŽ  â€œnext_eqv_distrâ€      â—‹(P â‰¡ Q) â‰¡ (â—‹(P) â‰¡ â—‹(Q))  âŠ¤
Conjectures:
NONE.
AutoLaws:
   i. simps:

  ii. folds:

 iii. unfolds:

ðŸ›  devproj.LTL> sh P

Completed Proofs (true names):
 next_eqv_distr  (red-L2R, size:7)
 next_and_distr  (red-L2R, size:7)
 next_or_distr  (red-All, size:11)
 next_false  (red-L2R, size:4)
 next_true  (red-L2R, size:3)
 linearity  (red-R2L, size:2)

ðŸ›  devproj.LTL> sh P linearity

linearity : â—‹(P) â‰¡ Â¬â—‹(Â¬P)
by 'red-R2L'
---
Â¬â—‹(Â¬P)
 = 'match-rhs next_self_dual @[]'
    { P  âŸ¼ Â¬P, â—‹  âŸ¼ â—‹, Â¬  âŸ¼ Â¬ }
â—‹(Â¬Â¬P)
 = 'match-lhs not_invol @[1]'
    { P  âŸ¼ P, Â¬  âŸ¼ Â¬ }
â—‹(P)

ðŸ›  devproj.LTL> sh P next_true

next_true : â—‹(true) â‰¡ true
by 'red-L2R'
---
â—‹(true)
 = 'match-eqv-pvar(2) imp_l-unit @[1]'
    { P  âŸ¼ true }
â—‹(true âŸ¹   true)
 = 'match-lhs next_implies_distr @[]'
    { P  âŸ¼ true, Q  âŸ¼ true, âŸ¹    âŸ¼ âŸ¹  , â—‹  âŸ¼ â—‹ }
â—‹(true) âŸ¹   â—‹(true)
 = 'match-lhs imp_refl @[]'
    { P  âŸ¼ â—‹(true), âŸ¹    âŸ¼ âŸ¹   }
true

ðŸ›  devproj.LTL> sh P next_false

next_false : â—‹(false) â‰¡ false
by 'red-L2R'
---
â—‹(false)
 = 'match-lhs linearity @[]'
    { P  âŸ¼ false, â—‹  âŸ¼ â—‹ }
Â¬â—‹(Â¬false)
 = 'match-lhs false_neg @[1,1]'
    { Â¬  âŸ¼ Â¬ }
Â¬â—‹(true)
 = 'match-lhs next_true @[1]'
    { â—‹  âŸ¼ â—‹ }
Â¬true
 = 'match-rhs false_def @[]'
    { Â¬  âŸ¼ Â¬ }
false

ðŸ›  devproj.LTL> sh P next_or_distr

next_or_distr : â—‹(P âˆ¨ Q) â‰¡ â—‹(P) âˆ¨ â—‹(Q)
by 'red-All'
---
â—‹(P âˆ¨ Q) â‰¡ â—‹(P) âˆ¨ â—‹(Q)
 = 'match-lhs linearity @[1]'
    { P  âŸ¼ P âˆ¨ Q, â—‹  âŸ¼ â—‹ }
Â¬â—‹(Â¬(P âˆ¨ Q)) â‰¡ â—‹(P) âˆ¨ â—‹(Q)
 = 'match-lhs linearity @[2,1]'
    { P  âŸ¼ P, â—‹  âŸ¼ â—‹ }
Â¬â—‹(Â¬(P âˆ¨ Q)) â‰¡ Â¬â—‹(Â¬P) âˆ¨ â—‹(Q)
 = 'match-lhs linearity @[2,2]'
    { P  âŸ¼ Q, â—‹  âŸ¼ â—‹ }
Â¬â—‹(Â¬(P âˆ¨ Q)) â‰¡ Â¬â—‹(Â¬P) âˆ¨ Â¬â—‹(Â¬Q)
 = 'match-rhs imp_def2 @[2]'
    { P  âŸ¼ â—‹(Â¬P), Q  âŸ¼ Â¬â—‹(Â¬Q), Â¬  âŸ¼ Â¬, âˆ¨  âŸ¼ âˆ¨ }
Â¬â—‹(Â¬(P âˆ¨ Q)) â‰¡ â—‹(Â¬P) âŸ¹   Â¬â—‹(Â¬Q)
 = 'match-rhs linearity @[2,2]'
    { P  âŸ¼ Q, â—‹  âŸ¼ â—‹, Â¬  âŸ¼ Â¬ }
Â¬â—‹(Â¬(P âˆ¨ Q)) â‰¡ â—‹(Â¬P) âŸ¹   â—‹(Q)
 = 'match-rhs next_implies_distr @[2]'
    { P  âŸ¼ Â¬P, Q  âŸ¼ Q, âŸ¹    âŸ¼ âŸ¹  , â—‹  âŸ¼ â—‹ }
Â¬â—‹(Â¬(P âˆ¨ Q)) â‰¡ â—‹(Â¬P âŸ¹   Q)
 = 'match-eqv-pvar(2) not_invol @[1,1,1,1,1]'
    { P  âŸ¼ P }
Â¬â—‹(Â¬(Â¬Â¬P âˆ¨ Q)) â‰¡ â—‹(Â¬P âŸ¹   Q)
 = 'match-rhs imp_def2 @[1,1,1,1]'
    { P  âŸ¼ Â¬P, Q  âŸ¼ Q, Â¬  âŸ¼ Â¬, âˆ¨  âŸ¼ âˆ¨ }
Â¬â—‹(Â¬(Â¬P âŸ¹   Q)) â‰¡ â—‹(Â¬P âŸ¹   Q)
 = 'match-lhs next_self_dual @[1,1]'
    { P  âŸ¼ Â¬P âŸ¹   Q, â—‹  âŸ¼ â—‹, Â¬  âŸ¼ Â¬ }
Â¬Â¬â—‹(Â¬P âŸ¹   Q) â‰¡ â—‹(Â¬P âŸ¹   Q)
 = 'match-lhs not_invol @[1]'
    { P  âŸ¼ â—‹(Â¬P âŸ¹   Q), Â¬  âŸ¼ Â¬ }
â—‹(Â¬P âŸ¹   Q) â‰¡ â—‹(Â¬P âŸ¹   Q)
 = 'match-all eqv_refl @[]'
    { P  âŸ¼ â—‹(Â¬P âŸ¹   Q), â‰¡  âŸ¼ â‰¡ }
true

ðŸ›  devproj.LTL> sh Pnext_and_dist next_and_distr

next_and_distr : â—‹(P âˆ§ Q) â‰¡ â—‹(P) âˆ§ â—‹(Q)
by 'red-L2R'
---
â—‹(P âˆ§ Q)
 = 'match-eqv-pvar(2) not_invol @[1]'
    { P  âŸ¼ P âˆ§ Q }
â—‹(Â¬Â¬(P âˆ§ Q))
 = 'match-lhs deMorgan_and @[1,1]'
    { P  âŸ¼ P, Q  âŸ¼ Q, âˆ§  âŸ¼ âˆ§, Â¬  âŸ¼ Â¬ }
â—‹(Â¬(Â¬P âˆ¨ Â¬Q))
 = 'match-lhs next_self_dual @[]'
    { P  âŸ¼ Â¬P âˆ¨ Â¬Q, â—‹  âŸ¼ â—‹, Â¬  âŸ¼ Â¬ }
Â¬â—‹(Â¬P âˆ¨ Â¬Q)
 = 'match-lhs next_or_distr @[1]'
    { P  âŸ¼ Â¬P, Q  âŸ¼ Â¬Q, â—‹  âŸ¼ â—‹, âˆ¨  âŸ¼ âˆ¨ }
Â¬(â—‹(Â¬P) âˆ¨ â—‹(Â¬Q))
 = 'match-lhs deMorgan_or @[]'
    { P  âŸ¼ â—‹(Â¬P), Q  âŸ¼ â—‹(Â¬Q), Â¬  âŸ¼ Â¬, âˆ¨  âŸ¼ âˆ¨ }
Â¬â—‹(Â¬P) âˆ§ Â¬â—‹(Â¬Q)
 = 'match-rhs linearity @[1]'
    { P  âŸ¼ P, â—‹  âŸ¼ â—‹, Â¬  âŸ¼ Â¬ }
â—‹(P) âˆ§ Â¬â—‹(Â¬Q)
 = 'match-rhs linearity @[2]'
    { P  âŸ¼ Q, â—‹  âŸ¼ â—‹, Â¬  âŸ¼ Â¬ }
â—‹(P) âˆ§ â—‹(Q)

ðŸ›  devproj.LTL> sh P next_eqv_distr

next_eqv_distr : â—‹(P â‰¡ Q) â‰¡ (â—‹(P) â‰¡ â—‹(Q))
by 'red-L2R'
---
â—‹(P â‰¡ Q)
 = 'match-equiv[1,2] eqv_def @[1]'
    { P  âŸ¼ P, Q  âŸ¼ Q, â‰¡  âŸ¼ â‰¡ }
â—‹(P âˆ§ Q âˆ¨ Â¬P âˆ§ Â¬Q)
 = 'match-lhs next_or_distr @[]'
    { P  âŸ¼ P âˆ§ Q, Q  âŸ¼ Â¬P âˆ§ Â¬Q, â—‹  âŸ¼ â—‹, âˆ¨  âŸ¼ âˆ¨ }
â—‹(P âˆ§ Q) âˆ¨ â—‹(Â¬P âˆ§ Â¬Q)
 = 'match-lhs next_and_distr @[1]'
    { P  âŸ¼ P, Q  âŸ¼ Q, âˆ§  âŸ¼ âˆ§, â—‹  âŸ¼ â—‹ }
â—‹(P) âˆ§ â—‹(Q) âˆ¨ â—‹(Â¬P âˆ§ Â¬Q)
 = 'match-lhs next_and_distr @[2]'
    { P  âŸ¼ Â¬P, Q  âŸ¼ Â¬Q, âˆ§  âŸ¼ âˆ§, â—‹  âŸ¼ â—‹ }
â—‹(P) âˆ§ â—‹(Q) âˆ¨ â—‹(Â¬P) âˆ§ â—‹(Â¬Q)
 = 'match-lhs next_self_dual @[2,1]'
    { P  âŸ¼ P, â—‹  âŸ¼ â—‹, Â¬  âŸ¼ Â¬ }
â—‹(P) âˆ§ â—‹(Q) âˆ¨ Â¬â—‹(P) âˆ§ â—‹(Â¬Q)
 = 'match-lhs next_self_dual @[2,2]'
    { P  âŸ¼ Q, â—‹  âŸ¼ â—‹, Â¬  âŸ¼ Â¬ }
â—‹(P) âˆ§ â—‹(Q) âˆ¨ Â¬â—‹(P) âˆ§ Â¬â—‹(Q)
 = 'match-equiv[3] eqv_def @[]'
    { P  âŸ¼ â—‹(P), Q  âŸ¼ â—‹(Q), âˆ§  âŸ¼ âˆ§, Â¬  âŸ¼ Â¬, âˆ¨  âŸ¼ âˆ¨ }
â—‹(P) â‰¡ â—‹(Q)


