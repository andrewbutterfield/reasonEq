-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.7).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module UTP.Par
  ( happyError
  , myLexer
  , pPred
  , pPred1
  , pPred2
  , pPred3
  , pPred4
  , pPred5
  , pPred6
  , pListPred
  , pExp
  , pExp1
  , pExp2
  , pExp3
  , pListExp
  ) where

import Prelude

import qualified UTP.Abs
import UTP.Lex

}

%name pPred Pred
%name pPred1 Pred1
%name pPred2 Pred2
%name pPred3 Pred3
%name pPred4 Pred4
%name pPred5 Pred5
%name pPred6 Pred6
%name pListPred ListPred
%name pExp Exp
%name pExp1 Exp1
%name pExp2 Exp2
%name pExp3 Exp3
%name pListExp ListExp
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='      { PT _ (TS _ 1)       }
  '('       { PT _ (TS _ 2)       }
  '(.'      { PT _ (TS _ 3)       }
  ')'       { PT _ (TS _ 4)       }
  '*'       { PT _ (TS _ 5)       }
  '+'       { PT _ (TS _ 6)       }
  '++'      { PT _ (TS _ 7)       }
  ','       { PT _ (TS _ 8)       }
  '-'       { PT _ (TS _ 9)       }
  '.)'      { PT _ (TS _ 10)      }
  '/\\'     { PT _ (TS _ 11)      }
  ':'       { PT _ (TS _ 12)      }
  '<'       { PT _ (TS _ 13)      }
  '<='      { PT _ (TS _ 14)      }
  '=='      { PT _ (TS _ 15)      }
  '==='     { PT _ (TS _ 16)      }
  '==>'     { PT _ (TS _ 17)      }
  '>'       { PT _ (TS _ 18)      }
  '>='      { PT _ (TS _ 19)      }
  'E'       { PT _ (TS _ 20)      }
  '\\/'     { PT _ (TS _ 21)      }
  'div'     { PT _ (TS _ 22)      }
  'mod'     { PT _ (TS _ 23)      }
  'neg'     { PT _ (TS _ 24)      }
  'nil'     { PT _ (TS _ 25)      }
  '~'       { PT _ (TS _ 26)      }
  L_integ   { PT _ (TI $$)        }
  L_Boolean { PT _ (T_Boolean $$) }
  L_DynVar  { PT _ (T_DynVar $$)  }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Boolean :: { UTP.Abs.Boolean }
Boolean  : L_Boolean { UTP.Abs.Boolean $1 }

DynVar :: { UTP.Abs.DynVar }
DynVar  : L_DynVar { UTP.Abs.DynVar $1 }

Pred :: { UTP.Abs.Pred }
Pred : Pred '===' Pred1 { UTP.Abs.PEqv $1 $3 } | Pred1 { $1 }

Pred1 :: { UTP.Abs.Pred }
Pred1 : Pred2 '==>' Pred1 { UTP.Abs.PImpl $1 $3 } | Pred2 { $1 }

Pred2 :: { UTP.Abs.Pred }
Pred2 : Pred2 '\\/' Pred3 { UTP.Abs.POr $1 $3 } | Pred3 { $1 }

Pred3 :: { UTP.Abs.Pred }
Pred3 : Pred3 '/\\' Pred4 { UTP.Abs.PAnd $1 $3 } | Pred4 { $1 }

Pred4 :: { UTP.Abs.Pred }
Pred4 : '~' Pred5 { UTP.Abs.PNot $2 } | Pred5 { $1 }

Pred5 :: { UTP.Abs.Pred }
Pred5
  : Exp '==' Exp { UTP.Abs.EQ $1 $3 }
  | Exp '!=' Exp { UTP.Abs.NE $1 $3 }
  | Exp '<' Exp { UTP.Abs.LT $1 $3 }
  | Exp '<=' Exp { UTP.Abs.LE $1 $3 }
  | Exp '>' Exp { UTP.Abs.GT $1 $3 }
  | Exp '>=' Exp { UTP.Abs.GE $1 $3 }
  | Pred6 { $1 }

Pred6 :: { UTP.Abs.Pred }
Pred6
  : DynVar { UTP.Abs.PVar $1 }
  | 'E' Exp { UTP.Abs.PLift $2 }
  | DynVar '(.' ListPred '.)' { UTP.Abs.PredTX $1 $3 }
  | '(' Pred ')' { $2 }

ListPred :: { [UTP.Abs.Pred] }
ListPred
  : {- empty -} { [] }
  | Pred { (:[]) $1 }
  | Pred ',' ListPred { (:) $1 $3 }

Exp :: { UTP.Abs.Exp }
Exp
  : Exp1 '++' Exp { UTP.Abs.ECat $1 $3 }
  | Exp1 ':' Exp { UTP.Abs.ECons $1 $3 }
  | Exp1 { $1 }

Exp1 :: { UTP.Abs.Exp }
Exp1
  : Exp1 '+' Exp2 { UTP.Abs.EAdd $1 $3 }
  | Exp1 '-' Exp2 { UTP.Abs.ESub $1 $3 }
  | Exp2 { $1 }

Exp2 :: { UTP.Abs.Exp }
Exp2
  : Exp2 '*' Exp3 { UTP.Abs.EMul $1 $3 }
  | Exp2 'div' Exp3 { UTP.Abs.EDiv $1 $3 }
  | Exp2 'mod' Exp3 { UTP.Abs.EMod $1 $3 }
  | 'neg' Exp3 { UTP.Abs.ENeg $2 }
  | Exp3 { $1 }

Exp3 :: { UTP.Abs.Exp }
Exp3
  : Integer { UTP.Abs.EInt $1 }
  | DynVar { UTP.Abs.EVar $1 }
  | Boolean { UTP.Abs.EBool $1 }
  | 'nil' { UTP.Abs.ENil }
  | DynVar '(' ListExp ')' { UTP.Abs.ENmdTuple $1 $3 }
  | '(' Exp ')' { $2 }

ListExp :: { [UTP.Abs.Exp] }
ListExp
  : {- empty -} { [] }
  | Exp { (:[]) $1 }
  | Exp ',' ListExp { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

