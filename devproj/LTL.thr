BEGIN THEORY LTL
DEPS = ["Equality","Exists","ForAll","Implies","AndOrInvert","And","Or","Not","Equiv"]
KNOWN = VD (fromList [(VR (Id "always" 0,VO,WS),KV (TF (TG (Id "B" 0)) (TG (Id "B" 0)))),(VR (Id "eventually" 0,VO,WS),KV (TF (TG (Id "B" 0)) (TG (Id "B" 0)))),(VR (Id "next" 0,VO,WS),KV (TF (TG (Id "B" 0)) (TG (Id "B" 0)))),(VR (Id "until" 0,VO,WS),KV (TF (TG (Id "B" 0)) (TF (TG (Id "B" 0)) (TG (Id "B" 0))))),(VR (Id "wait" 0,VO,WS),KV (TF (TG (Id "B" 0)) (TF (TG (Id "B" 0)) (TG (Id "B" 0)))))],fromList [],fromList [])
BEGIN LIST LAWS
(("next_self_dual",ASN (C (TF TB (TG (Id "B" 0))) True (Id "eqv" 0) [C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))]],C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))]]],([],fromList []))),Axiom)
(("next_implies_distr",ASN (C (TF TB (TG (Id "B" 0))) True (Id "eqv" 0) [C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [C (TF TB (TG (Id "B" 0))) True (Id "imp" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS)),V (TF TB (TG (Id "B" 0))) (VR (Id "Q" 0,VP,WS))]],C (TF TB (TG (Id "B" 0))) True (Id "imp" 0) [C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))],C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "Q" 0,VP,WS))]]],([],fromList []))),Axiom)
(("linearity",ASN (C (TF TB (TG (Id "B" 0))) True (Id "eqv" 0) [C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))],C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))]]]],([],fromList []))),Proven "linearity")
END LIST LAWS
BEGIN LIST PROOFS
("linearity",ASN (C (TF TB (TG (Id "B" 0))) True (Id "eqv" 0) [C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))],C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))]]]],([],fromList [])),"red-R2L",(C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))],[(UseLaw (ByMatch MER) "next_self_dual" (BD (fromList [((Id "P" 0,VP),BT (C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))])),((Id "next" 0,VO),BV (VR (Id "next" 0,VO,WS))),((Id "not" 0,VO),BV (VR (Id "not" 0,VO,WS)))],fromList [],fromList [])) [],ASN (C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))]]],([],fromList []))),(UseLaw (ByMatch MEL) "not_invol" (BD (fromList [((Id "P" 0,VP),BV (VR (Id "P" 0,VP,WS))),((Id "not" 0,VO),BV (VR (Id "not" 0,VO,WS)))],fromList [],fromList [])) [1],ASN (C (TF TB (TG (Id "B" 0))) True (Id "next" 0) [C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [C (TF TB (TG (Id "B" 0))) True (Id "not" 0) [V (TF TB (TG (Id "B" 0))) (VR (Id "P" 0,VP,WS))]]],([],fromList [])))]))
END LIST PROOFS
BEGIN LIST SIMPLIFIERS
END LIST SIMPLIFIERS
BEGIN LIST DEFFOLD
END LIST DEFFOLD
BEGIN LIST DEFUNFOLD
END LIST DEFUNFOLD
BEGIN LIST CONJECTURES
END LIST CONJECTURES
END THEORY LTL
