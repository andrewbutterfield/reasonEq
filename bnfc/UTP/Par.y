-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.7).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module UTP.Par
  ( happyError
  , myLexer
  , pPred
  , pPred1
  , pPred2
  , pPred3
  , pPred4
  , pPred5
  , pExp
  , pExp1
  , pExp2
  , pExp3
  ) where

import Prelude

import qualified UTP.Abs
import UTP.Lex

}

%name pPred Pred
%name pPred1 Pred1
%name pPred2 Pred2
%name pPred3 Pred3
%name pPred4 Pred4
%name pPred5 Pred5
%name pExp Exp
%name pExp1 Exp1
%name pExp2 Exp2
%name pExp3 Exp3
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('       { PT _ (TS _ 1)       }
  ')'       { PT _ (TS _ 2)       }
  '*'       { PT _ (TS _ 3)       }
  '+'       { PT _ (TS _ 4)       }
  '++'      { PT _ (TS _ 5)       }
  '-'       { PT _ (TS _ 6)       }
  '/\\'     { PT _ (TS _ 7)       }
  ':'       { PT _ (TS _ 8)       }
  '==='     { PT _ (TS _ 9)       }
  '==>'     { PT _ (TS _ 10)      }
  '\\/'     { PT _ (TS _ 11)      }
  'div'     { PT _ (TS _ 12)      }
  'mod'     { PT _ (TS _ 13)      }
  'nil'     { PT _ (TS _ 14)      }
  '~'       { PT _ (TS _ 15)      }
  L_Ident   { PT _ (TV $$)        }
  L_integ   { PT _ (TI $$)        }
  L_Boolean { PT _ (T_Boolean $$) }

%%

Ident :: { UTP.Abs.Ident }
Ident  : L_Ident { UTP.Abs.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Boolean :: { UTP.Abs.Boolean }
Boolean  : L_Boolean { UTP.Abs.Boolean $1 }

Pred :: { UTP.Abs.Pred }
Pred : Pred '===' Pred1 { UTP.Abs.PEqv $1 $3 } | Pred1 { $1 }

Pred1 :: { UTP.Abs.Pred }
Pred1 : Pred2 '==>' Pred1 { UTP.Abs.PImpl $1 $3 } | Pred2 { $1 }

Pred2 :: { UTP.Abs.Pred }
Pred2 : Pred2 '\\/' Pred3 { UTP.Abs.POr $1 $3 } | Pred3 { $1 }

Pred3 :: { UTP.Abs.Pred }
Pred3 : Pred3 '/\\' Pred4 { UTP.Abs.PAnd $1 $3 } | Pred4 { $1 }

Pred4 :: { UTP.Abs.Pred }
Pred4 : '~' Pred5 { UTP.Abs.PNot $2 } | Pred5 { $1 }

Pred5 :: { UTP.Abs.Pred }
Pred5 : Exp { UTP.Abs.PAtomic $1 } | '(' Pred ')' { $2 }

Exp :: { UTP.Abs.Exp }
Exp
  : Exp1 '++' Exp { UTP.Abs.ECat $1 $3 }
  | Exp1 ':' Exp { UTP.Abs.ECons $1 $3 }
  | Exp1 { $1 }

Exp1 :: { UTP.Abs.Exp }
Exp1
  : Exp1 '+' Exp2 { UTP.Abs.EAdd $1 $3 }
  | Exp1 '-' Exp2 { UTP.Abs.ESub $1 $3 }
  | Exp2 { $1 }

Exp2 :: { UTP.Abs.Exp }
Exp2
  : Exp2 '*' Exp3 { UTP.Abs.EMul $1 $3 }
  | Exp2 'div' Exp3 { UTP.Abs.EDiv $1 $3 }
  | Exp2 'mod' Exp3 { UTP.Abs.EMod $1 $3 }
  | Exp3 { $1 }

Exp3 :: { UTP.Abs.Exp }
Exp3
  : Integer { UTP.Abs.EInt $1 }
  | Ident { UTP.Abs.EVar $1 }
  | Boolean { UTP.Abs.EBool $1 }
  | 'nil' { UTP.Abs.ENil }
  | '(' Exp ')' { $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

