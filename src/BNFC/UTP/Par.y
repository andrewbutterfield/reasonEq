-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.7).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module UTP.Par
  ( happyError
  , myLexer
  , pTheory
  , pTerm
  , pType
  , pSCond
  ) where

import Prelude

import qualified UTP.Abs
import UTP.Lex

}

%name pTheory Theory
%name pTerm Term
%name pType Type
%name pSCond SCond
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='         { PT _ (TS _ 1)      }
  '('          { PT _ (TS _ 2)      }
  '(:'         { PT _ (TS _ 3)      }
  ')'          { PT _ (TS _ 4)      }
  '*'          { PT _ (TS _ 5)      }
  '+'          { PT _ (TS _ 6)      }
  '++'         { PT _ (TS _ 7)      }
  ','          { PT _ (TS _ 8)      }
  '-'          { PT _ (TS _ 9)      }
  '->'         { PT _ (TS _ 10)     }
  '.'          { PT _ (TS _ 11)     }
  '.]'         { PT _ (TS _ 12)     }
  '/'          { PT _ (TS _ 13)     }
  '/\\'        { PT _ (TS _ 14)     }
  ':'          { PT _ (TS _ 15)     }
  ':)'         { PT _ (TS _ 16)     }
  ';'          { PT _ (TS _ 17)     }
  '<'          { PT _ (TS _ 18)     }
  '<='         { PT _ (TS _ 19)     }
  '=='         { PT _ (TS _ 20)     }
  '==='        { PT _ (TS _ 21)     }
  '==>'        { PT _ (TS _ 22)     }
  '>'          { PT _ (TS _ 23)     }
  '>='         { PT _ (TS _ 24)     }
  'Conjecture' { PT _ (TS _ 25)     }
  'DclASet'    { PT _ (TS _ 26)     }
  'DclDLVar'   { PT _ (TS _ 27)     }
  'DclVar'     { PT _ (TS _ 28)     }
  'Exp'        { PT _ (TS _ 29)     }
  'False'      { PT _ (TS _ 30)     }
  'Law'        { PT _ (TS _ 31)     }
  'NA'         { PT _ (TS _ 32)     }
  'NS'         { PT _ (TS _ 33)     }
  'Obs'        { PT _ (TS _ 34)     }
  'Prd'        { PT _ (TS _ 35)     }
  'SB'         { PT _ (TS _ 36)     }
  'SC'         { PT _ (TS _ 37)     }
  'Sub'        { PT _ (TS _ 38)     }
  'SubL'       { PT _ (TS _ 39)     }
  'SubV'       { PT _ (TS _ 40)     }
  'Theory'     { PT _ (TS _ 41)     }
  'True'       { PT _ (TS _ 42)     }
  'VSC'        { PT _ (TS _ 43)     }
  '[.'         { PT _ (TS _ 44)     }
  '\\/'        { PT _ (TS _ 45)     }
  'assumed'    { PT _ (TS _ 46)     }
  'axiom'      { PT _ (TS _ 47)     }
  'covby'      { PT _ (TS _ 48)     }
  'dcovby'     { PT _ (TS _ 49)     }
  'disj'       { PT _ (TS _ 50)     }
  'div'        { PT _ (TS _ 51)     }
  'false'      { PT _ (TS _ 52)     }
  'fresh'      { PT _ (TS _ 53)     }
  'lst'        { PT _ (TS _ 54)     }
  'mod'        { PT _ (TS _ 55)     }
  'neg'        { PT _ (TS _ 56)     }
  'nil'        { PT _ (TS _ 57)     }
  'none'       { PT _ (TS _ 58)     }
  'proven'     { PT _ (TS _ 59)     }
  'std'        { PT _ (TS _ 60)     }
  'tbot'       { PT _ (TS _ 61)     }
  'true'       { PT _ (TS _ 62)     }
  'ttop'       { PT _ (TS _ 63)     }
  'var'        { PT _ (TS _ 64)     }
  '|'          { PT _ (TS _ 65)     }
  '~'          { PT _ (TS _ 66)     }
  L_integ      { PT _ (TI $$)       }
  L_DynVar     { PT _ (T_DynVar $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

DynVar :: { UTP.Abs.DynVar }
DynVar  : L_DynVar { UTP.Abs.DynVar $1 }

Theory :: { UTP.Abs.Theory }
Theory
  : 'Theory' DynVar '.' ListDynVar '.' ListItem { UTP.Abs.Thry $2 $4 $6 }

ListDynVar :: { [UTP.Abs.DynVar] }
ListDynVar : {- empty -} { [] } | DynVar ListDynVar { (:) $1 $2 }

Item :: { UTP.Abs.Item }
Item
  : 'DclVar' VarClass DynVar '.' VarRole '.' { UTP.Abs.DeclVar $2 $3 $5 }
  | 'DclDLVar' VarClass DynVar '.' ListDynVar '.' { UTP.Abs.DeclDLVar $2 $3 $5 }
  | 'DclASet' VarClass DynVar '.' { UTP.Abs.DeclASet $2 $3 }
  | 'Conjecture' DynVar '.' Term '.' SCond { UTP.Abs.Conj $2 $4 $6 }
  | 'Law' LawType DynVar '.' Term '.' SCond { UTP.Abs.Law $2 $3 $5 $7 }

VarRole :: { UTP.Abs.VarRole }
VarRole : 'var' SBBL Type { UTP.Abs.VMR_KV $2 $3 }

VarClass :: { UTP.Abs.VarClass }
VarClass
  : 'Obs' { UTP.Abs.VarObs }
  | 'Exp' { UTP.Abs.VarExp }
  | 'Prd' { UTP.Abs.VarPred }

SBBL :: { UTP.Abs.SBBL }
SBBL
  : 'NA' { UTP.Abs.SBBL_NA }
  | 'SB' { UTP.Abs.SBBL_SB }
  | 'NS' { UTP.Abs.SBBL_NS }

LawType :: { UTP.Abs.LawType }
LawType
  : 'axiom' { UTP.Abs.LAxiom }
  | 'proven' { UTP.Abs.LProof }
  | 'assumed' { UTP.Abs.LAssume }

ListItem :: { [UTP.Abs.Item] }
ListItem : {- empty -} { [] } | Item ListItem { (:) $1 $2 }

Term :: { UTP.Abs.Term }
Term : Term '===' Term1 { UTP.Abs.PEqv $1 $3 } | Term1 { $1 }

Term1 :: { UTP.Abs.Term }
Term1 : Term2 '==>' Term1 { UTP.Abs.PImpl $1 $3 } | Term2 { $1 }

Term2 :: { UTP.Abs.Term }
Term2 : Term2 '\\/' Term3 { UTP.Abs.POr $1 $3 } | Term3 { $1 }

Term3 :: { UTP.Abs.Term }
Term3
  : Term3 '/\\' Term4 { UTP.Abs.PAnd $1 $3 }
  | '~' Term4 { UTP.Abs.PNot $2 }
  | Term4 { $1 }

Term4 :: { UTP.Abs.Term }
Term4
  : Term5 '==' Term5 { UTP.Abs.EQ $1 $3 }
  | Term5 '!=' Term5 { UTP.Abs.NE $1 $3 }
  | Term5 '<' Term5 { UTP.Abs.LT $1 $3 }
  | Term5 '<=' Term5 { UTP.Abs.LE $1 $3 }
  | Term5 '>' Term5 { UTP.Abs.GT $1 $3 }
  | Term5 '>=' Term5 { UTP.Abs.GE $1 $3 }
  | 'True' { UTP.Abs.PTrue }
  | 'False' { UTP.Abs.PFalse }
  | DynVar { UTP.Abs.PVar $1 }
  | Term5 { $1 }

Term5 :: { UTP.Abs.Term }
Term5
  : Term6 '++' Term5 { UTP.Abs.LCat $1 $3 }
  | Term6 ':' Term5 { UTP.Abs.LCons $1 $3 }
  | Term6 { $1 }

Term6 :: { UTP.Abs.Term }
Term6
  : Term6 '+' Term7 { UTP.Abs.EAdd $1 $3 }
  | Term6 '-' Term7 { UTP.Abs.EMinus $1 $3 }
  | Term7 { $1 }

Term7 :: { UTP.Abs.Term }
Term7
  : Term7 '*' Term8 { UTP.Abs.EMul $1 $3 }
  | Term7 'div' Term8 { UTP.Abs.EDiv $1 $3 }
  | Term7 'mod' Term8 { UTP.Abs.EMod $1 $3 }
  | 'neg' Term8 { UTP.Abs.ENeg $2 }
  | Term8 { $1 }

Term8 :: { UTP.Abs.Term }
Term8
  : Integer { UTP.Abs.EInt $1 }
  | DynVar { UTP.Abs.EVar $1 }
  | 'true' { UTP.Abs.ETrue }
  | 'false' { UTP.Abs.EFalse }
  | 'nil' { UTP.Abs.ENil }
  | DynVar '(' ListTerm ')' { UTP.Abs.TCons $1 $3 }
  | 'SubV' Term '[.' ListTerm '/' ListDynVar '.]' { UTP.Abs.TSubV $2 $4 $6 }
  | 'SubL' Term '[.' ListDynVar '/' ListDynVar '.]' { UTP.Abs.TSubLV $2 $4 $6 }
  | 'Sub' Term '[.' ListTerm '/' ListDynVar '|' ListDynVar '/' ListDynVar '.]' { UTP.Abs.TSubst $2 $4 $6 $8 $10 }
  | '(' Term ')' { $2 }

ListTerm :: { [UTP.Abs.Term] }
ListTerm
  : {- empty -} { [] }
  | Term { (:[]) $1 }
  | Term ',' ListTerm { (:) $1 $3 }

Type :: { UTP.Abs.Type }
Type : Type1 '->' Type { UTP.Abs.TFun $1 $3 } | Type1 { $1 }

Type1 :: { UTP.Abs.Type }
Type1
  : DynVar '(:' ListType2 ':)' { UTP.Abs.TRec $1 $3 } | Type2 { $1 }

Type2 :: { UTP.Abs.Type }
Type2 : DynVar ListType3 { UTP.Abs.TProd $1 $2 } | Type3 { $1 }

Type3 :: { UTP.Abs.Type }
Type3
  : 'ttop' { UTP.Abs.TArb }
  | DynVar { UTP.Abs.TVar $1 }
  | 'tbot' { UTP.Abs.TBot }
  | '(' Type ')' { $2 }

ListType2 :: { [UTP.Abs.Type] }
ListType2
  : {- empty -} { [] }
  | Type2 { (:[]) $1 }
  | Type2 '|' ListType2 { (:) $1 $3 }

ListType3 :: { [UTP.Abs.Type] }
ListType3 : {- empty -} { [] } | Type3 ListType3 { (:) $1 $2 }

GVar :: { UTP.Abs.GVar }
GVar
  : 'std' DynVar { UTP.Abs.SVar $2 }
  | 'lst' DynVar { UTP.Abs.LVar $2 }

ListGVar :: { [UTP.Abs.GVar] }
ListGVar
  : {- empty -} { [] }
  | GVar { (:[]) $1 }
  | GVar ',' ListGVar { (:) $1 $3 }

VarSet :: { UTP.Abs.VarSet }
VarSet : ListGVar { UTP.Abs.VSet $1 }

VSCond :: { UTP.Abs.VSCond }
VSCond
  : GVar 'disj' VarSet { UTP.Abs.VSCDisj $1 $3 }
  | GVar 'covby' VarSet { UTP.Abs.VSCCovBy $1 $3 }
  | GVar 'dcovby' VarSet { UTP.Abs.VSCDynCov $1 $3 }

ListVSCond :: { [UTP.Abs.VSCond] }
ListVSCond
  : {- empty -} { [] }
  | VSCond { (:[]) $1 }
  | VSCond ';' ListVSCond { (:) $1 $3 }

SCond :: { UTP.Abs.SCond }
SCond
  : 'SC' ListVSCond '.' VarSet '.' { UTP.Abs.SCFull $2 $4 }
  | 'VSC' ListVSCond '.' { UTP.Abs.SCVSCs $2 }
  | 'fresh' VarSet '.' { UTP.Abs.SCFresh $2 }
  | 'none' { UTP.Abs.SCnone }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

