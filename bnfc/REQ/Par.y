-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.7).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module REQ.Par
  ( happyError
  , myLexer
  , pThry
  , pTrm
  , pTyp
  , pSCond
  ) where

import Prelude

import qualified REQ.Abs
import REQ.Lex

}

%name pThry Thry
%name pTrm Trm
%name pTyp Typ
%name pSCond SCond
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='         { PT _ (TS _ 1)      }
  '%'          { PT _ (TS _ 2)      }
  '('          { PT _ (TS _ 3)      }
  '(:'         { PT _ (TS _ 4)      }
  ')'          { PT _ (TS _ 5)      }
  '*'          { PT _ (TS _ 6)      }
  '+'          { PT _ (TS _ 7)      }
  '++'         { PT _ (TS _ 8)      }
  ','          { PT _ (TS _ 9)      }
  '-'          { PT _ (TS _ 10)     }
  '->'         { PT _ (TS _ 11)     }
  '.'          { PT _ (TS _ 12)     }
  '.]'         { PT _ (TS _ 13)     }
  '/'          { PT _ (TS _ 14)     }
  '/\\'        { PT _ (TS _ 15)     }
  ':'          { PT _ (TS _ 16)     }
  ':)'         { PT _ (TS _ 17)     }
  ';'          { PT _ (TS _ 18)     }
  '<'          { PT _ (TS _ 19)     }
  '<='         { PT _ (TS _ 20)     }
  '=='         { PT _ (TS _ 21)     }
  '==='        { PT _ (TS _ 22)     }
  '==>'        { PT _ (TS _ 23)     }
  '>'          { PT _ (TS _ 24)     }
  '>='         { PT _ (TS _ 25)     }
  'BndL'       { PT _ (TS _ 26)     }
  'BndS'       { PT _ (TS _ 27)     }
  'Close'      { PT _ (TS _ 28)     }
  'Conjecture' { PT _ (TS _ 29)     }
  'DclASet'    { PT _ (TS _ 30)     }
  'DclDLVar'   { PT _ (TS _ 31)     }
  'DclVar'     { PT _ (TS _ 32)     }
  'Exp'        { PT _ (TS _ 33)     }
  'ExprVars'   { PT _ (TS _ 34)     }
  'False'      { PT _ (TS _ 35)     }
  'Iter'       { PT _ (TS _ 36)     }
  'Law'        { PT _ (TS _ 37)     }
  'NA'         { PT _ (TS _ 38)     }
  'NS'         { PT _ (TS _ 39)     }
  'Obs'        { PT _ (TS _ 40)     }
  'ObsVars'    { PT _ (TS _ 41)     }
  'Prd'        { PT _ (TS _ 42)     }
  'PredVars'   { PT _ (TS _ 43)     }
  'SB'         { PT _ (TS _ 44)     }
  'SC'         { PT _ (TS _ 45)     }
  'StaticVars' { PT _ (TS _ 46)     }
  'Sub'        { PT _ (TS _ 47)     }
  'SubL'       { PT _ (TS _ 48)     }
  'SubV'       { PT _ (TS _ 49)     }
  'Theory'     { PT _ (TS _ 50)     }
  'True'       { PT _ (TS _ 51)     }
  'VSC'        { PT _ (TS _ 52)     }
  '['          { PT _ (TS _ 53)     }
  '[.'         { PT _ (TS _ 54)     }
  '\\/'        { PT _ (TS _ 55)     }
  ']'          { PT _ (TS _ 56)     }
  'assumed'    { PT _ (TS _ 57)     }
  'axiom'      { PT _ (TS _ 58)     }
  'covby'      { PT _ (TS _ 59)     }
  'dcovby'     { PT _ (TS _ 60)     }
  'disj'       { PT _ (TS _ 61)     }
  'fresh'      { PT _ (TS _ 62)     }
  'lst'        { PT _ (TS _ 63)     }
  'nil'        { PT _ (TS _ 64)     }
  'none'       { PT _ (TS _ 65)     }
  'proven'     { PT _ (TS _ 66)     }
  'std'        { PT _ (TS _ 67)     }
  'tbot'       { PT _ (TS _ 68)     }
  'ttop'       { PT _ (TS _ 69)     }
  'var'        { PT _ (TS _ 70)     }
  '|'          { PT _ (TS _ 71)     }
  '~'          { PT _ (TS _ 72)     }
  L_integ      { PT _ (TI $$)       }
  L_DynVar     { PT _ (T_DynVar $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

DynVar :: { REQ.Abs.DynVar }
DynVar  : L_DynVar { REQ.Abs.DynVar $1 }

Thry :: { REQ.Abs.Thry }
Thry
  : 'Theory' DynVar '.' ListDynVar '.' ListItem { REQ.Abs.Thr $2 $4 $6 }

ListDynVar :: { [REQ.Abs.DynVar] }
ListDynVar : {- empty -} { [] } | DynVar ListDynVar { (:) $1 $2 }

Item :: { REQ.Abs.Item }
Item
  : 'ObsVars' ListDynVar '.' { REQ.Abs.DefObs $2 }
  | 'ExprVars' ListDynVar '.' { REQ.Abs.DefExpr $2 }
  | 'PredVars' ListDynVar '.' { REQ.Abs.DefPred $2 }
  | 'StaticVars' ListDynVar '.' { REQ.Abs.DefStatic $2 }
  | 'DclVar' VClass DynVar '.' VarRole '.' { REQ.Abs.DeclVar $2 $3 $5 }
  | 'DclDLVar' VClass DynVar '.' ListDynVar '.' { REQ.Abs.DeclDLVar $2 $3 $5 }
  | 'DclASet' VClass DynVar '.' { REQ.Abs.DeclASet $2 $3 }
  | 'Law' LawType DynVar '.' Trm '.' SCond { REQ.Abs.Law $2 $3 $5 $7 }
  | 'Conjecture' DynVar '.' Trm '.' SCond { REQ.Abs.Conj $2 $4 $6 }

VarRole :: { REQ.Abs.VarRole }
VarRole : 'var' SBBL Typ { REQ.Abs.KV $2 $3 }

VClass :: { REQ.Abs.VClass }
VClass
  : 'Obs' { REQ.Abs.VarObs }
  | 'Exp' { REQ.Abs.VarExp }
  | 'Prd' { REQ.Abs.VarPred }

SBBL :: { REQ.Abs.SBBL }
SBBL
  : 'NA' { REQ.Abs.Na } | 'SB' { REQ.Abs.SB } | 'NS' { REQ.Abs.NS }

LawType :: { REQ.Abs.LawType }
LawType
  : 'axiom' { REQ.Abs.LAxiom }
  | 'proven' { REQ.Abs.LProof }
  | 'assumed' { REQ.Abs.LAssume }

ListItem :: { [REQ.Abs.Item] }
ListItem : {- empty -} { [] } | Item ListItem { (:) $1 $2 }

Trm :: { REQ.Abs.Trm }
Trm : Trm '===' Trm1 { REQ.Abs.PEqv $1 $3 } | Trm1 { $1 }

Trm1 :: { REQ.Abs.Trm }
Trm1 : Trm2 '==>' Trm1 { REQ.Abs.PImpl $1 $3 } | Trm2 { $1 }

Trm2 :: { REQ.Abs.Trm }
Trm2 : Trm2 '\\/' Trm3 { REQ.Abs.POr $1 $3 } | Trm3 { $1 }

Trm3 :: { REQ.Abs.Trm }
Trm3
  : Trm3 '/\\' Trm4 { REQ.Abs.PAnd $1 $3 }
  | '~' Trm4 { REQ.Abs.PNot $2 }
  | Trm4 { $1 }

Trm4 :: { REQ.Abs.Trm }
Trm4
  : Trm5 '==' Trm5 { REQ.Abs.Eql $1 $3 }
  | Trm5 '!=' Trm5 { REQ.Abs.NE $1 $3 }
  | Trm5 '<' Trm5 { REQ.Abs.Lt $1 $3 }
  | Trm5 '<=' Trm5 { REQ.Abs.LE $1 $3 }
  | Trm5 '>' Trm5 { REQ.Abs.Gt $1 $3 }
  | Trm5 '>=' Trm5 { REQ.Abs.GE $1 $3 }
  | Trm5 { $1 }

Trm5 :: { REQ.Abs.Trm }
Trm5
  : Trm6 '++' Trm5 { REQ.Abs.LCat $1 $3 }
  | Trm6 ':' Trm5 { REQ.Abs.LCons $1 $3 }
  | Trm6 { $1 }

Trm6 :: { REQ.Abs.Trm }
Trm6
  : Trm6 '+' Trm7 { REQ.Abs.EAdd $1 $3 }
  | Trm6 '-' Trm7 { REQ.Abs.EMinus $1 $3 }
  | Trm7 { $1 }

Trm7 :: { REQ.Abs.Trm }
Trm7
  : Trm7 '*' Trm8 { REQ.Abs.EMul $1 $3 }
  | Trm7 '/' Trm8 { REQ.Abs.EDiv $1 $3 }
  | Trm7 '%' Trm8 { REQ.Abs.EMod $1 $3 }
  | '-' Trm8 { REQ.Abs.ENeg $2 }
  | Trm8 { $1 }

Trm8 :: { REQ.Abs.Trm }
Trm8
  : Integer { REQ.Abs.EInt $1 }
  | DynVar { REQ.Abs.TmVar $1 }
  | 'True' { REQ.Abs.TTrue }
  | 'False' { REQ.Abs.TFalse }
  | 'nil' { REQ.Abs.ENil }
  | DynVar '(' ListTrm ')' { REQ.Abs.TCons $1 $3 }
  | 'BndS' DynVar '[' ListGVar ']' Trm { REQ.Abs.TBndSet $2 $4 $6 }
  | 'BndL' DynVar '[' ListGVar ']' Trm { REQ.Abs.TBndLst $2 $4 $6 }
  | 'Close' DynVar Trm { REQ.Abs.TClose $2 $3 }
  | 'SubV' Trm '[.' ListTrm '/' ListDynVar '.]' { REQ.Abs.TSubV $2 $4 $6 }
  | 'SubL' Trm '[.' ListDynVar '/' ListDynVar '.]' { REQ.Abs.TSubLV $2 $4 $6 }
  | 'Sub' Trm '[.' ListTrm '/' ListDynVar '|' ListDynVar '/' ListDynVar '.]' { REQ.Abs.TSubst $2 $4 $6 $8 $10 }
  | 'Iter' DynVar DynVar '[' ListDynVar ']' { REQ.Abs.TIter $2 $3 $5 }
  | '(' Trm ')' { $2 }

ListTrm :: { [REQ.Abs.Trm] }
ListTrm
  : {- empty -} { [] }
  | Trm { (:[]) $1 }
  | Trm ',' ListTrm { (:) $1 $3 }

Typ :: { REQ.Abs.Typ }
Typ : Typ1 '->' Typ { REQ.Abs.TFun $1 $3 } | Typ1 { $1 }

Typ1 :: { REQ.Abs.Typ }
Typ1
  : DynVar '(:' ListTyp2 ':)' { REQ.Abs.TRec $1 $3 } | Typ2 { $1 }

Typ2 :: { REQ.Abs.Typ }
Typ2 : DynVar ListTyp3 { REQ.Abs.TProd $1 $2 } | Typ3 { $1 }

Typ3 :: { REQ.Abs.Typ }
Typ3
  : 'ttop' { REQ.Abs.TArb }
  | DynVar { REQ.Abs.TVbl $1 }
  | 'tbot' { REQ.Abs.TBot }
  | '(' Typ ')' { $2 }

ListTyp2 :: { [REQ.Abs.Typ] }
ListTyp2
  : {- empty -} { [] }
  | Typ2 { (:[]) $1 }
  | Typ2 '|' ListTyp2 { (:) $1 $3 }

ListTyp3 :: { [REQ.Abs.Typ] }
ListTyp3 : {- empty -} { [] } | Typ3 ListTyp3 { (:) $1 $2 }

GVar :: { REQ.Abs.GVar }
GVar
  : 'std' DynVar { REQ.Abs.SVar $2 }
  | 'lst' DynVar { REQ.Abs.LVar $2 }

ListGVar :: { [REQ.Abs.GVar] }
ListGVar
  : {- empty -} { [] }
  | GVar { (:[]) $1 }
  | GVar ',' ListGVar { (:) $1 $3 }

VrSet :: { REQ.Abs.VrSet }
VrSet : ListGVar { REQ.Abs.VSet $1 }

VSCond :: { REQ.Abs.VSCond }
VSCond
  : GVar 'disj' VrSet { REQ.Abs.VSCDisj $1 $3 }
  | GVar 'covby' VrSet { REQ.Abs.VSCCovBy $1 $3 }
  | GVar 'dcovby' VrSet { REQ.Abs.VSCDynCov $1 $3 }

ListVSCond :: { [REQ.Abs.VSCond] }
ListVSCond
  : {- empty -} { [] }
  | VSCond { (:[]) $1 }
  | VSCond ';' ListVSCond { (:) $1 $3 }

SCond :: { REQ.Abs.SCond }
SCond
  : 'SC' ListVSCond '.' VrSet '.' { REQ.Abs.SCFull $2 $4 }
  | 'VSC' ListVSCond '.' { REQ.Abs.SCVSCs $2 }
  | 'fresh' VrSet '.' { REQ.Abs.SCFresh $2 }
  | 'none' { REQ.Abs.SCnone }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

