-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.7).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module UTP.Par
  ( happyError
  , myLexer
  , pTheory
  , pTerm
  , pType
  ) where

import Prelude

import qualified UTP.Abs
import UTP.Lex

}

%name pTheory Theory
%name pTerm Term
%name pType Type
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='         { PT _ (TS _ 1)      }
  '('          { PT _ (TS _ 2)      }
  '(.'         { PT _ (TS _ 3)      }
  '(:'         { PT _ (TS _ 4)      }
  ')'          { PT _ (TS _ 5)      }
  '*'          { PT _ (TS _ 6)      }
  '+'          { PT _ (TS _ 7)      }
  '++'         { PT _ (TS _ 8)      }
  ','          { PT _ (TS _ 9)      }
  '-'          { PT _ (TS _ 10)     }
  '->'         { PT _ (TS _ 11)     }
  '.'          { PT _ (TS _ 12)     }
  '.)'         { PT _ (TS _ 13)     }
  '/'          { PT _ (TS _ 14)     }
  '/\\'        { PT _ (TS _ 15)     }
  ':'          { PT _ (TS _ 16)     }
  ':)'         { PT _ (TS _ 17)     }
  '<'          { PT _ (TS _ 18)     }
  '<='         { PT _ (TS _ 19)     }
  '=='         { PT _ (TS _ 20)     }
  '==='        { PT _ (TS _ 21)     }
  '==>'        { PT _ (TS _ 22)     }
  '>'          { PT _ (TS _ 23)     }
  '>='         { PT _ (TS _ 24)     }
  'Conjecture' { PT _ (TS _ 25)     }
  'DclASet'    { PT _ (TS _ 26)     }
  'DclDLVar'   { PT _ (TS _ 27)     }
  'DclVar'     { PT _ (TS _ 28)     }
  'Exp'        { PT _ (TS _ 29)     }
  'False'      { PT _ (TS _ 30)     }
  'Law'        { PT _ (TS _ 31)     }
  'NA'         { PT _ (TS _ 32)     }
  'NS'         { PT _ (TS _ 33)     }
  'Obs'        { PT _ (TS _ 34)     }
  'Prd'        { PT _ (TS _ 35)     }
  'SB'         { PT _ (TS _ 36)     }
  'Sub'        { PT _ (TS _ 37)     }
  'SubL'       { PT _ (TS _ 38)     }
  'SubV'       { PT _ (TS _ 39)     }
  'Theory'     { PT _ (TS _ 40)     }
  'True'       { PT _ (TS _ 41)     }
  '\\/'        { PT _ (TS _ 42)     }
  'assumed'    { PT _ (TS _ 43)     }
  'axiom'      { PT _ (TS _ 44)     }
  'div'        { PT _ (TS _ 45)     }
  'false'      { PT _ (TS _ 46)     }
  'mod'        { PT _ (TS _ 47)     }
  'neg'        { PT _ (TS _ 48)     }
  'nil'        { PT _ (TS _ 49)     }
  'proven'     { PT _ (TS _ 50)     }
  'tbot'       { PT _ (TS _ 51)     }
  'true'       { PT _ (TS _ 52)     }
  'ttop'       { PT _ (TS _ 53)     }
  'var'        { PT _ (TS _ 54)     }
  '|'          { PT _ (TS _ 55)     }
  '~'          { PT _ (TS _ 56)     }
  L_integ      { PT _ (TI $$)       }
  L_DynVar     { PT _ (T_DynVar $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

DynVar :: { UTP.Abs.DynVar }
DynVar  : L_DynVar { UTP.Abs.DynVar $1 }

Theory :: { UTP.Abs.Theory }
Theory
  : 'Theory' DynVar '.' ListDynVar '.' ListItem { UTP.Abs.Thry $2 $4 $6 }

ListDynVar :: { [UTP.Abs.DynVar] }
ListDynVar : {- empty -} { [] } | DynVar ListDynVar { (:) $1 $2 }

Item :: { UTP.Abs.Item }
Item
  : 'DclVar' VarClass DynVar '.' VarRole '.' { UTP.Abs.DeclVar $2 $3 $5 }
  | 'DclDLVar' VarClass DynVar '.' ListDynVar '.' { UTP.Abs.DeclDLVar $2 $3 $5 }
  | 'DclASet' VarClass DynVar '.' { UTP.Abs.DeclASet $2 $3 }
  | 'Conjecture' DynVar '.' Term '.' { UTP.Abs.Conj $2 $4 }
  | 'Law' LawType DynVar '.' Term '.' { UTP.Abs.Law $2 $3 $5 }

VarRole :: { UTP.Abs.VarRole }
VarRole : 'var' SBBL Type { UTP.Abs.VMR_KV $2 $3 }

VarClass :: { UTP.Abs.VarClass }
VarClass
  : 'Obs' { UTP.Abs.VarObs }
  | 'Exp' { UTP.Abs.VarExp }
  | 'Prd' { UTP.Abs.VarPred }

SBBL :: { UTP.Abs.SBBL }
SBBL
  : 'NA' { UTP.Abs.SBBL_NA }
  | 'SB' { UTP.Abs.SBBL_SB }
  | 'NS' { UTP.Abs.SBBL_NS }

LawType :: { UTP.Abs.LawType }
LawType
  : 'axiom' { UTP.Abs.LAxiom }
  | 'proven' { UTP.Abs.LProof }
  | 'assumed' { UTP.Abs.LAssume }

ListItem :: { [UTP.Abs.Item] }
ListItem : {- empty -} { [] } | Item ListItem { (:) $1 $2 }

Term :: { UTP.Abs.Term }
Term : Term '===' Term1 { UTP.Abs.PEqv $1 $3 } | Term1 { $1 }

Term1 :: { UTP.Abs.Term }
Term1 : Term2 '==>' Term1 { UTP.Abs.PImpl $1 $3 } | Term2 { $1 }

Term2 :: { UTP.Abs.Term }
Term2 : Term2 '\\/' Term3 { UTP.Abs.POr $1 $3 } | Term3 { $1 }

Term3 :: { UTP.Abs.Term }
Term3
  : Term3 '/\\' Term4 { UTP.Abs.PAnd $1 $3 }
  | '~' Term4 { UTP.Abs.PNot $2 }
  | Term4 { $1 }

Term4 :: { UTP.Abs.Term }
Term4
  : Term5 '==' Term5 { UTP.Abs.EQ $1 $3 }
  | Term5 '!=' Term5 { UTP.Abs.NE $1 $3 }
  | Term5 '<' Term5 { UTP.Abs.LT $1 $3 }
  | Term5 '<=' Term5 { UTP.Abs.LE $1 $3 }
  | Term5 '>' Term5 { UTP.Abs.GT $1 $3 }
  | Term5 '>=' Term5 { UTP.Abs.GE $1 $3 }
  | 'True' { UTP.Abs.PTrue }
  | 'False' { UTP.Abs.PFalse }
  | DynVar { UTP.Abs.PVar $1 }
  | Term5 { $1 }

Term5 :: { UTP.Abs.Term }
Term5
  : Term6 '++' Term5 { UTP.Abs.LCat $1 $3 }
  | Term6 ':' Term5 { UTP.Abs.LCons $1 $3 }
  | Term6 { $1 }

Term6 :: { UTP.Abs.Term }
Term6
  : Term6 '+' Term7 { UTP.Abs.EAdd $1 $3 }
  | Term6 '-' Term7 { UTP.Abs.EMinus $1 $3 }
  | Term7 { $1 }

Term7 :: { UTP.Abs.Term }
Term7
  : Term7 '*' Term8 { UTP.Abs.EMul $1 $3 }
  | Term7 'div' Term8 { UTP.Abs.EDiv $1 $3 }
  | Term7 'mod' Term8 { UTP.Abs.EMod $1 $3 }
  | 'neg' Term8 { UTP.Abs.ENeg $2 }
  | Term8 { $1 }

Term8 :: { UTP.Abs.Term }
Term8
  : Integer { UTP.Abs.EInt $1 }
  | DynVar { UTP.Abs.EVar $1 }
  | 'true' { UTP.Abs.ETrue }
  | 'false' { UTP.Abs.EFalse }
  | 'nil' { UTP.Abs.ENil }
  | DynVar '(' ListTerm ')' { UTP.Abs.TCons $1 $3 }
  | 'SubV' Term '(.' ListTerm '/' ListDynVar '.)' { UTP.Abs.TSubV $2 $4 $6 }
  | 'SubL' Term '(.' ListDynVar '/' ListDynVar '.)' { UTP.Abs.TSubLV $2 $4 $6 }
  | 'Sub' Term '(.' ListTerm '/' ListDynVar '|' ListDynVar '/' ListDynVar '.)' { UTP.Abs.TSubst $2 $4 $6 $8 $10 }
  | '(' Term ')' { $2 }

ListTerm :: { [UTP.Abs.Term] }
ListTerm
  : {- empty -} { [] }
  | Term { (:[]) $1 }
  | Term ',' ListTerm { (:) $1 $3 }

Type :: { UTP.Abs.Type }
Type : Type1 '->' Type { UTP.Abs.TFun $1 $3 } | Type1 { $1 }

Type1 :: { UTP.Abs.Type }
Type1
  : DynVar '(:' ListType2 ':)' { UTP.Abs.TRec $1 $3 } | Type2 { $1 }

Type2 :: { UTP.Abs.Type }
Type2 : DynVar ListType3 { UTP.Abs.TProd $1 $2 } | Type3 { $1 }

Type3 :: { UTP.Abs.Type }
Type3
  : 'ttop' { UTP.Abs.TArb }
  | DynVar { UTP.Abs.TVar $1 }
  | 'tbot' { UTP.Abs.TBot }
  | '(' Type ')' { $2 }

ListType2 :: { [UTP.Abs.Type] }
ListType2
  : {- empty -} { [] }
  | Type2 { (:[]) $1 }
  | Type2 '|' ListType2 { (:) $1 $3 }

ListType3 :: { [UTP.Abs.Type] }
ListType3 : {- empty -} { [] } | Type3 ListType3 { (:) $1 $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

