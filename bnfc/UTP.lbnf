{-
  LBNF Syntax for reasonEq Terms and Theories,
  with an emphasis on Unifying Theories of Programming

  The plan is to replace the current editable syntax in UTP
  (Theory.src) with a nicer syntax.

  Currently a theory file has the format:

  Theory <thryname>
  Needs
    <importnm1> <importnm2> ... <importnmN>
  END
  Known A {O NS} : ( ( P LE ) -> ( B -> ( ( P LE ) -> B ) ) ) .
  Known 'ls {O} : ( P LE ) .
  Known ls' {O} : ( P LE ) .
  Known 'O$ = < 's,'ls >
  Law <lawname> BEGIN
    axiom ,
    <predicate> ,
  VREL (DISJ E FROM 'O$ O$') ... (DYNCOV a BY 's s')
  END
  Conjecture <conjname> BEGIN
    <predicate>
  , VREL <atomicSc1> ... <atomicScN>
  END

  We need (bottom-up)
    Types  -- done
    Expressions -- covers arithmetic and cons-lists
    Predicates 
      -- covers propositions, equality, ordering, predicate transformers
    Variable Data
      -- this is a monster - see below
      -- now we only implement what is actually used.
    Here: we have enough to represent most of the propositional theories

    Once quantifiers are introduced we need:
    Substitutions
    Side-Conditions

    Top-level theory structuring:
    Named-Assertions
    Known-Declarations
    Theory-Imports
    Named-Theory

-}


-- we want identifiers to start with letters and underscores
token DynVar  ( (letter|'_') (letter|digit|'_')* ) ;

-- token SBBL ( {"NA"} | {"SB"} | {"NS"} ) ; -- n/a, subable, not-subable


{- Theories
   SourceHandling syntex (.src)

   Theory EQV
   Known eqv {O CS} : ( B -> ( B -> B ) ) .
   Law true BEGIN axiom, true END
   Law eqv_refl BEGIN axiom, eqv ( P , P ) END
   Law non_subst 
     BEGIN axiom
       , eqv ( SUB [(x$,e$)] P , P )
       , VREL (DISJ P FROM x$)
     END
   Conjecture eqv_id BEGIN eqv ( eqv ( true , Q ) , Q ) END

   So, a theory has:
     a name;
     a list of zero or more dependent theories;
     a list of one of more theory items.
   Theory items are:
     Known variable declarations;
     Conjectures;
     Laws.
-}

Thry. Theory ::= "Theory" DynVar "." [DynVar] "." [Item] ;

separator DynVar "" ;

{- Variable Data 

      newtype VarTable
        = VD ( String
            , Map Variable   VarMatchRole
            , Map Variable   LstVarMatchRole
            , Map IdAndClass DynamicLstVarRole
            )

      data VarMatchRole -- Variable Matching Role
        =  KT Term     -- Known Term   -- used in Proto.thr
        |  KV Type (Maybe Subable) -- Known Variable -- widely used
        |  KG          -- Generic Variable -- used in Proto.thr
        |  KI Variable -- Instance Variable ! variable must be known as generic
                              -- used in Proto.thr
        |  UV          -- Unknown Variable -- never explicitly represented

      data LstVarMatchRole -- ListVar Matching Roles
      = KL VarList        -- Known Variable-List (all known?) -- Proto.thr
            [Variable]     -- full expansion
            Int            -- length of full expansion
      | KS VarSet         -- Known Variable-Set (all known?) -- Proto.thr
            (Set Variable) -- full expansion
            Int            -- size of full expansion
      | AL                -- Abstract Known Variable-List  -- Proto.thr
      | AS                -- Abstract Known Variable-Set -- Proto.thr
      | UL                -- Unknown List-Variable -- never explicitly represented

      data DynamicLstVarRole -- Dynamic ListVar Matching Roles
      = DL [Identifier]      -- Known-list, Variable identifiers -- UTCP,Proto
            [Identifier]      -- Known-list, List-Variable identifiers
            [Identifier]      -- full expansion
            Int               -- length of full expansion
      | DS (Set Identifier)  -- Known-set, Variable identifiers -- Proto.thr
            (Set Identifier)  -- Known-set, List-Variable identifiers
            (Set Identifier)  -- full expansion
            Int               -- size of full expansion
      | DAL                  -- Abstract Known List  -- Proto.thr
      | DAS                  -- Abstract Known Set   -- UWhile,Proto
      | UD         -- Unknown Dynamic List-Variable

  For now we only implement stuff actually used !
  This is  KV DL DAS 
-}


DeclVar.   Item ::= "DclVar" DynVar "." VarRole "."    ;  -- KV
DeclDLVar. Item ::= "DclDLVar" DynVar "." [DynVar] "." ;  -- DL
DeclASet.  Item ::= "DclASet" DynVar "."               ;  -- DAS
Conj.      Item ::= "Conjecture" DynVar "." Pred "."   ;
Law.       Item ::= "Law" LawType DynVar "." Pred "."  ;


VMR_KV. VarRole ::= "var" SBBL Type ;

SBBL_NA. SBBL ::= "NA" ;
SBBL_SB. SBBL ::= "SB" ;
SBBL_NS. SBBL ::= "NS" ;

LAxiom.  LawType ::= "axiom" ;
LProof.  LawType ::= "proven" ;
LAssume. LawType ::= "assumed" ;

separator Item "" ;


{- Predicates
   Propositional precedence:  tight..loose: ~ /\ \/ ==> ===
-}
PEqv.  Pred  ::= Pred "===" Pred1   ;
PImpl. Pred1 ::= Pred2 "==>" Pred1  ;
POr.   Pred2 ::= Pred2 "\\/" Pred3  ;
PAnd.  Pred3 ::= Pred3 "/\\" Pred4  ;
PNot.  Pred4 ::= "~" Pred5          ;
EQ.    Pred5 ::= Exp "==" Exp       ; 
NE.    Pred5 ::= Exp "!=" Exp       ; 
LT.    Pred5 ::= Exp "<" Exp        ; 
LE.    Pred5 ::= Exp "<=" Exp       ; 
GT.    Pred5 ::= Exp ">" Exp        ; 
GE.    Pred5 ::= Exp ">=" Exp       ; 
PVar.  Pred6 ::= DynVar             ;
PExpr. Pred6 ::= "E" Exp            ;
PType. Pred6 ::= "T" Type ;
PredTX. Pred6 ::= DynVar "(." [Pred] ".)" ;
coercions Pred 6                    ;
separator Pred "," ;

{- Expressions  
  Haskell operators:
   Prc | Left-Assoc           |         Non-Assoc            | Right-Assoc
    9  | !!                   |                              | . 
    8  |                      |                              | ^ ^^ **
    7  | * / div mod rem quot |                              | 
    6  | + -                  |                              |
    5  |                      |                              | : ++
    4  |                      | == /= < <= > >= elem notElem | 
    3  |                      |                              | &&
    2  |                      |                              | ||
    1  | >> >>=               |                              |
    0  |                      |                              | $ $! seq    
-}


ECat.  Exp  ::= Exp1  "++" Exp  ;
ECons. Exp  ::= Exp1  ":"  Exp  ;
EAdd.  Exp1 ::= Exp1  "+"  Exp2 ;
ESub.  Exp1 ::= Exp1  "-"  Exp2 ;
EMul.  Exp2 ::= Exp2  "*"  Exp3 ;
EDiv.  Exp2 ::= Exp2 "div" Exp3 ;
EMod.  Exp2 ::= Exp2 "mod" Exp3 ;
ENeg.  Exp2 ::= "neg" Exp3      ;
EInt.  Exp3 ::= Integer         ;
EVar.  Exp3 ::= DynVar          ;
ETrue. Exp3 ::= "true"          ;
EFalse. Exp3 ::= "false"          ;
ENil.  Exp3 ::= "nil"           ;
ENmdTuple. Exp3 ::= DynVar "(" [Exp] ")" ;
coercions Exp 3                 ;
separator Exp "," ;

{- Types
  reasonEq Type(s)
    ArbType
    TypeVar i  
    TypeCons i ts 
    AlgType i fs 
    FunType td tr 
    GivenType i  - here we treat these as TypeVar
    BottomType
    ts = [t1,..,tN]
    fs = [(i_1,ts_1),..,(i_M,ts_M)]
    t1 -> t2 -> t3   is  t1 -> (t2 -> t3)
-}

TFun.  Type ::= Type1 "->" Type ;
TRec.  Type1 ::= DynVar "(:" [Type2] ":)" ;
TProd. Type2 ::= DynVar [Type3] ;
TArb.  Type3 ::= "ttop" ;
TVar.  Type3 ::= DynVar ; 
TBot.  Type3 ::= "tbot" ;
coercions Type 3 ;
separator Type2 "|" ;
separator Type3 "" ;

entrypoints Theory, Pred, Exp, Type ;