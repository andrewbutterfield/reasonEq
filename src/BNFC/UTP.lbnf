{-
  LBNF Syntax for reasonEq Terms and Theories,
  with an emphasis on Unifying Theories of Programming

  The plan is to replace the current editable syntax in UTP
  (Theory.src) with a nicer syntax.

  Currently a theory file has the format:

  Theory <thryname>
  Needs
    <importnm1> <importnm2> ... <importnmN>
  END
  Known A {O NS} : ( ( P LE ) -> ( B -> ( ( P LE ) -> B ) ) ) .
  Known 'ls {O} : ( P LE ) .
  Known ls' {O} : ( P LE ) .
  Known 'O$ = < 's,'ls >
  Law <lawname> BEGIN
    axiom ,
    <predicate> ,
  VREL (DISJ E FROM 'O$ O$') ... (DYNCOV a BY 's s')
  END
  Conjecture <conjname> BEGIN
    <predicate>
  , VREL <atomicSc1> ... <atomicScN>
  END

  We need (bottom-up)
    Types  -- done
    Expressions -- covers arithmetic and cons-lists
    Predicates 
      -- covers propositions, equality, ordering, predicate transformers
    Terms = Expressions+Predicates -- done
    Variable Data -- covers what's actually used
      -- this is a monster - see below
      -- now we only implement what is actually used.
    Substitutions -- done
    Side-Conditions -- done
    Quantifiers -- TBD
    Iterators, etc.... TBD
    Top-level theory structuring: -- done
      Named-Assertions; Known-Declarations; Theory-Imports; Named-Theory

-}

-- we want identifiers to start with letters and underscores
token DynVar  ( (letter|'_') (letter|digit|'_')* ) ;

{- Theories
   SourceHandling syntex  ( .src )

   Theory EQV
   Known eqv {O CS} : ( B -> ( B -> B ) ) .
   Law true BEGIN axiom, true END
   Law eqv_refl BEGIN axiom, eqv ( P , P ) END
   Law non_subst 
     BEGIN axiom
       , eqv ( SUB [(x$,e$)] P , P )
       , VREL (DISJ P FROM x$)
     END
   Conjecture eqv_id BEGIN eqv ( eqv ( true , Q ) , Q ) END

   So, a theory has:
     a name;
     a list of zero or more dependent theories;
     a list of one of more theory items.
   Theory items are:
     Known variable declarations;
     Conjectures;
     Laws.
-}

Thry. Theory ::= "Theory" DynVar "." [DynVar] "." [Item] ;

separator DynVar "" ;

{- Variable Data 

      newtype VarTable
        = VD ( String
            , Map Variable   VarMatchRole
            , Map Variable   LstVarMatchRole
            , Map IdAndClass DynamicLstVarRole
            )

      data VarMatchRole -- Variable Matching Role
        =  KT Term     -- Known Term   -- used in Proto.thr
        |  KV Type (Maybe Subable) -- Known Variable -- widely used
        |  KG          -- Generic Variable -- used in Proto.thr
        |  KI Variable -- Instance Variable ! variable must be known as generic
                              -- used in Proto.thr
        |  UV          -- Unknown Variable -- never explicitly represented

      data LstVarMatchRole -- ListVar Matching Roles
      = KL VarList        -- Known Variable-List (all known?) -- Proto.thr
            [Variable]     -- full expansion
            Int            -- length of full expansion
      | KS VarSet         -- Known Variable-Set (all known?) -- Proto.thr
            (Set Variable) -- full expansion
            Int            -- size of full expansion
      | AL                -- Abstract Known Variable-List  -- Proto.thr
      | AS                -- Abstract Known Variable-Set -- Proto.thr
      | UL                -- Unknown List-Variable -- never explicitly represented

      data DynamicLstVarRole -- Dynamic ListVar Matching Roles
      = DL [Identifier]      -- Known-list, Variable identifiers -- UTCP,Proto
            [Identifier]      -- Known-list, List-Variable identifiers
            [Identifier]      -- full expansion
            Int               -- length of full expansion
      | DS (Set Identifier)  -- Known-set, Variable identifiers -- Proto.thr
            (Set Identifier)  -- Known-set, List-Variable identifiers
            (Set Identifier)  -- full expansion
            Int               -- size of full expansion
      | DAL                  -- Abstract Known List  -- Proto.thr
      | DAS                  -- Abstract Known Set   -- UWhile,Proto
      | UD         -- Unknown Dynamic List-Variable

  For now we only implement stuff actually used !
  This is  KV DL DAS 
-}

DeclVar.   Item ::= "DclVar" VarClass DynVar "." VarRole "."    ;  -- KV
DeclDLVar. Item ::= "DclDLVar" VarClass DynVar "." [DynVar] "." ;  -- DL
DeclASet.  Item ::= "DclASet" VarClass DynVar "."               ;  -- DAS
Conj.      Item ::= "Conjecture" DynVar "." Term "." SCond  ;
Law.       Item ::= "Law" LawType DynVar "." Term "." SCond  ;

VMR_KV. VarRole ::= "var" SBBL Type ;

VarObs. VarClass ::= "Obs" ;
VarExp. VarClass ::= "Exp" ;
VarPred. VarClass ::= "Prd" ;

SBBL_NA. SBBL ::= "NA" ;
SBBL_SB. SBBL ::= "SB" ;
SBBL_NS. SBBL ::= "NS" ;

LAxiom.  LawType ::= "axiom" ;
LProof.  LawType ::= "proven" ;
LAssume. LawType ::= "assumed" ;

separator Item "" ;

{- Terms (Expressions,Predicates)
   Haskell and Propositional binary operators (tightest first):
      | Left-Assoc           |         Non-Assoc            | Right-Assoc
      | !!                   |                              | . 
      |                      |                              | ^ ^^ **
   7  | * / div mod rem quot |                              | 
   6  | + -                  |                              |
   5  |                      |                              | : ++
   4  |                      | == /= < <= > >= elem notElem |
                  programs as predicates will probably live here      
   3  |                      |                              | && /\
   2  |                      |                              | || \/
   1  |                      |                              | ==>
   0  |                      |                              | ===
      | >> >>=               |                              |
      |                      |                              | $ $! seq   
-}
PEqv.   Term  ::= Term "===" Term1 ;
PImpl.  Term1 ::= Term2 "==>" Term1 ;
POr.    Term2 ::= Term2 "\\/" Term3 ;
PAnd.   Term3 ::= Term3 "/\\" Term4 ;
PNot.   Term3 ::= "~" Term4 ;
-- program predicates ?
EQ.     Term4 ::= Term5 "==" Term5 ;
NE.     Term4 ::= Term5 "!=" Term5 ;
LT.     Term4 ::= Term5 "<" Term5 ;
LE.     Term4 ::= Term5 "<=" Term5 ;
GT.     Term4 ::= Term5 ">" Term5 ;
GE.     Term4 ::= Term5 ">=" Term5 ;
PTrue.  Term4 ::= "True" ;
PFalse. Term4 ::= "False" ;
PVar.   Term4 ::= DynVar ;
LCat.   Term5 ::= Term6  "++" Term5 ;
LCons.  Term5 ::= Term6  ":"  Term5 ;
EAdd.   Term6 ::= Term6  "+"  Term7 ;
EMinus. Term6 ::= Term6  "-"  Term7 ;
EMul.   Term7 ::= Term7  "*"  Term8 ;
EDiv.   Term7 ::= Term7 "div" Term8 ;
EMod.   Term7 ::= Term7 "mod" Term8 ;
ENeg.   Term7 ::= "neg" Term8 ;
EInt.   Term8 ::= Integer ;
EVar.   Term8 ::= DynVar ;
ETrue.  Term8 ::= "true" ;
EFalse. Term8 ::= "false" ;
ENil.   Term8 ::= "nil" ;
TCons.  Term8 ::= DynVar "(" [Term] ")" ;
TSubV. Term8  ::= "SubV" Term "[." [Term] "/" [DynVar] ".]" ;
TSubLV. Term8 ::= "SubL" Term  "[." [DynVar] "/" [DynVar] ".]" ;
TSubst. Term8 ::= "Sub" Term 
                     "[." [Term] "/" [DynVar] 
                          "|" 
                          [DynVar] "/" [DynVar]
                     ".]" ;
coercions Term 8 ;
separator Term "," ;


{- Types
  reasonEq Type(s)
    ArbType
    TypeVar i  
    TypeCons i ts 
    AlgType i fs 
    FunType td tr 
    GivenType i  - here we treat these as TypeVar
    BottomType
    ts = [t1,..,tN]
    fs = [(i_1,ts_1),..,(i_M,ts_M)]
    t1 -> t2 -> t3   is  t1 -> (t2 -> t3)
-}

TFun.  Type ::= Type1 "->" Type ;
TRec.  Type1 ::= DynVar "(:" [Type2] ":)" ;
TProd. Type2 ::= DynVar [Type3] ;
TArb.  Type3 ::= "ttop" ;
TVar.  Type3 ::= DynVar ; 
TBot.  Type3 ::= "tbot" ;
coercions Type 3 ;
separator Type2 "|" ;
separator Type3 "" ;

{- Side-Conditions
    type SideCond = ( [VarSideConds]  -- all must be true
                    , VarSet )       -- must be fresh
    data  VarSideConds -- (V,D,C,Cd)
      = VSC  GenVar      --  v,T,l$
            (NA VarSet)  --  D, if applicable
            (NA VarSet)  --  C, if applicable
            (NA VarSet)  --  Cd, if applicable
    data NA t = NA | The t -- we can ignore this
-}

SVar. GVar ::= "std" DynVar ;
LVar. GVar ::= "lst" DynVar ;
separator GVar "," ;

VSet. VarSet ::= [GVar] ;

VSCDisj.   VSCond ::= GVar "disj"   VarSet ;
VSCCovBy.  VSCond ::= GVar "covby"  VarSet ;
VSCDynCov. VSCond ::= GVar "dcovby" VarSet ;
separator VSCond ";" ;

SCFull.  SCond ::= "SC" [VSCond] "." VarSet "." ;
SCVSCs.  SCond ::= "VSC" [VSCond] "." ;
SCFresh. SCond ::= "fresh" VarSet "." ;
SCnone.  SCond ::= "none" ;

entrypoints Theory, Term, Type, SCond ;